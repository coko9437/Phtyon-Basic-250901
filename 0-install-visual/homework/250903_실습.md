
---

### 📌 기본 실습 1: 클래스와 객체 생성

**문제 목표**
`Person`이라는 '설계도(클래스)'를 만들고, 이 설계도를 바탕으로 '철수'라는 실제 사람(객체)을 만들어 자기소개를 시키는 것입니다.

**핵심 개념**
-   **클래스(Class)**: 객체를 만들기 위한 템플릿.
-   **객체(Object)/인스턴스(Instance)**: 클래스로부터 생성된 실체.
-   **`__init__` (생성자)**: 객체가 생성될 때 속성을 초기화하는 특별한 메서드.
-   **인스턴스 변수**: `self.변수명` 형태로, 각 객체가 독립적으로 가지는 데이터.
-   **인스턴스 메서드**: 객체가 수행할 수 있는 행동(함수).

---

#### 구조 설계

1.  **클래스 이름**: `Person`
2.  **필요한 데이터(속성)**:
    -   이름 (`name`)
    -   나이 (`age`)
3.  **필요한 기능(메서드)**:
    -   객체가 처음 만들어질 때 이름과 나이를 설정하는 기능 (`__init__`)
    -   "안녕하세요, 저는 OOO이고 OO살입니다."라고 소개하는 기능 (`introduce`)

---

#### 상세 설명

**1. `class Person:`**
-   `Person`이라는 이름의 클래스(설계도)를 정의하겠다는 선언입니다. 클래스 이름은 보통 대문자로 시작합니다.

**2. `def __init__(self, name, age):` (생성자 메서드)**
-   **왜 `__init__`을 써야 하나요?**: `__init__`은 "initialize(초기화하다)"의 약자로, **객체가 생성되는 바로 그 순간에 자동으로 호출되는** 특별한 약속과 같은 메서드입니다. 객체가 만들어질 때 이름, 나이와 같이 꼭 필요한 초기값을 설정해주기 위해 사용합니다. `p = Person("철수", 25)` 코드가 실행될 때, 파이썬은 자동으로 `__init__` 메서드를 찾아 실행합니다.
-   **`self`는 무엇인가요?**: `self`는 **"객체 자기 자신"**을 의미하는 약속된 이름입니다. `p = Person("철수", 25)` 코드로 객체를 만들 때, `self`는 바로 `p`를 가리키게 됩니다. 클래스 내의 모든 메서드는 첫 번째 인자로 항상 `self`를 받아, "이 메서드를 호출한 객체가 누구인지"를 알 수 있게 합니다.
-   `(self, name, age)`: 이 메서드는 `self` 외에 `name`과 `age`라는 두 개의 추가 인자를 받습니다. `"철수"`가 `name`으로, `25`가 `age`로 전달됩니다.

**3. `self.name = name` 과 `self.age = age`**
-   **왜 `self.name`이라고 쓰나요?**: 이 코드는 **"객체(self)의 고유한 공간에 `name`이라는 속성(변수)을 만들고, 외부에서 전달받은 `name`의 값('철수')을 저장하라"**는 의미입니다. 이렇게 `self.`을 붙여야만 `name`과 `age`가 객체의 고유한 속성이 되어, `introduce` 같은 다른 메서드에서도 `self.name` 형태로 값을 꺼내 쓸 수 있습니다. 그냥 `name = name`이라고 쓰면, 이 변수는 `__init__` 메서드가 끝나면 사라지는 지역 변수가 되어버립니다.

**4. `def introduce(self):` (인스턴스 메서드)**
-   `Person` 객체가 수행할 수 있는 '행동'을 정의합니다. 이 메서드도 `self`를 첫 인자로 받아, 이 메서드를 호출한 객체가 누구인지 알 수 있습니다.
-   `print(f"...")`: f-string을 사용하여 `self.name`과 `self.age`에 저장된 **객체 자신의** 이름과 나이를 가져와 문장을 완성하고 출력합니다.

---

#### 전체 코드 예시

```python
# '사람'에 대한 설계도(클래스)를 정의합니다.
class Person:
    # 1. 생성자 메서드: 객체가 생성될 때 이름과 나이를 받아 초기화합니다.
    def __init__(self, name, age):
        # self: 생성되는 객체 자기 자신
        # self.name = name: 전달받은 name 값을 객체의 name 속성에 저장
        print(f"__init__ 호출: '{name}' 객체를 생성합니다.")
        self.name = name
        self.age = age

    # 2. 자기소개 메서드
    def introduce(self):
        # self.name과 self.age를 사용해 객체 자신의 정보에 접근합니다.
        print(f"안녕하세요, 저는 {self.name}이고 {self.age}살입니다.")

# --- 실행 부분 ---
# Person 클래스(설계도)를 사용해 'cheolsu'라는 실제 객체(인스턴스)를 생성합니다.
# 이 때 __init__ 메서드가 자동으로 호출됩니다.
cheolsu = Person("철수", 25)

# 생성된 객체의 메서드를 호출합니다.
cheolsu.introduce()

# 객체의 속성에 직접 접근하여 출력할 수도 있습니다.
print(f"객체의 이름 속성: {cheolsu.name}")
```

---

### 📌 기본 실습 2: 상속과 메서드 오버라이딩

**문제 목표**
`Animal`이라는 공통된 특징을 가진 부모 클래스를 만들고, 이를 상속받은 `Dog`와 `Cat`이 각자의 방식으로 '소리내는' 기능을 갖도록 하는 것입니다.

**핵심 개념**
-   **상속(Inheritance)**: 부모 클래스의 속성과 메서드를 자식 클래스가 그대로 물려받는 기능.
-   **메서드 오버라이딩(Method Overriding)**: 부모에게 물려받은 메서드를 자식 클래스에서 자신에게 맞게 **재정의**하는 것.
-   **다형성(Polymorphism)**: 같은 `sound()` 호출이라도, 객체의 실제 타입(`Dog` 또는 `Cat`)에 따라 다른 결과가 나오는 현상.

---

#### 구조 설계

1.  **부모 클래스**: `Animal`
    -   **메서드**: `sound()` (기본 소리)
2.  **자식 클래스 1**: `Dog`
    -   **상속**: `Animal`로부터 상속받음
    -   **메서드 오버라이딩**: `sound()`를 "멍멍!"으로 재정의
3.  **자식 클래스 2**: `Cat`
    -   **상속**: `Animal`로부터 상속받음
    -   **메서드 오버라이딩**: `sound()`를 "야옹~"으로 재정의

---

#### 상세 설명

**1. `class Animal:`**
-   모든 동물이 공통으로 가질 기능을 정의하는 부모 클래스입니다.
-   `def sound(self):`: "동물 소리"라는 기본적인 소리 기능을 정의합니다. 자식 클래스가 이 메서드를 재정의하지 않으면 이 기본 기능이 사용됩니다.

**2. `class Dog(Animal):`**
-   **왜 `(Animal)`을 쓰나요?**: 클래스 이름 뒤에 괄호를 쓰고 다른 클래스 이름을 넣으면, **상속 관계**가 만들어집니다. `Dog`는 `Animal`의 모든 속성과 메서드를 물려받게 됩니다.

**3. `def sound(self):` (in `Dog` and `Cat`)**
-   **메서드 오버라이딩**: `Dog`와 `Cat` 클래스 안에 부모와 **똑같은 이름의** `sound` 메서드를 또 정의했습니다. 이것을 '메서드 오버라이딩'이라고 합니다.
-   이제 `Dog` 객체의 `sound` 메서드를 호출하면, 부모인 `Animal`의 `sound`가 아닌, `Dog` 클래스에 **새롭게 정의된** `sound` 메서드가 실행됩니다. `Cat`도 마찬가지입니다.

---

#### 전체 코드 예시

```python
# 부모 클래스 Animal을 정의합니다.
class Animal:
    def sound(self):
        print("동물 소리")

# Animal 클래스를 상속받는 Dog 클래스를 정의합니다.
class Dog(Animal):
    # 부모의 sound() 메서드를 재정의(오버라이딩)합니다.
    def sound(self):
        print("멍멍!")

# Animal 클래스를 상속받는 Cat 클래스를 정의합니다.
class Cat(Animal):
    # 부모의 sound() 메서드를 재정의(오버라이딩)합니다.
    def sound(self):
        print("야옹~")

# --- 실행 부분 ---
my_dog = Dog()
my_cat = Cat()

print("강아지 소리:")
my_dog.sound()  # Dog 클래스에 재정의된 메서드가 호출됩니다.

print("고양이 소리:")
my_cat.sound()  # Cat 클래스에 재정의된 메서드가 호출됩니다.

# 다형성 확인
animals = [Dog(), Cat()] # 리스트에 서로 다른 타입의 객체를 담음
print("\n--- 다형성 테스트 ---")
for animal in animals:
    # 같은 animal.sound() 호출이지만, 객체의 실제 타입에 따라 다른 결과가 나옵니다.
    animal.sound()
```

---

### 📌 기본 실습 3: 캡슐화 (가시성 제어)

**문제 목표**
은행 계좌의 잔액(`balance`)을 외부에서 마음대로 수정할 수 없도록 막고, 오직 '입금'과 '조회'라는 정해진 방법으로만 접근할 수 있도록 안전하게 만드는 것입니다.

**핵심 개념**
-   **캡슐화(Encapsulation)**: 데이터(속성)와 그 데이터를 다루는 기능(메서드)을 하나로 묶고, 중요한 데이터는 외부로부터 숨기는 것.
-   **Private 변수**: 변수 이름 앞에 `__`(언더스코어 두 개)를 붙여 외부에서의 직접 접근을 막습니다.
-   **Getter**: Private 변수의 값을 **읽을 수 있게** 해주는 메서드.
-   **Setter**: Private 변수의 값을 **안전하게 변경할 수 있게** 해주는 메서드.

---

#### 구조 설계

1.  **클래스**: `BankAccount`
2.  **속성**:
    -   `owner` (예금주, public)
    -   `__balance` (잔액, private)
3.  **메서드**:
    -   `__init__`: `owner`와 `__balance` 초기화
    -   `deposit`: `__balance`에 금액을 더하는 기능 (Setter 역할)
    -   `get_balance`: `__balance`의 값을 반환하는 기능 (Getter 역할)

---

#### 상세 설명

**1. `self.__balance = balance`**
-   **왜 `__`를 쓰나요?**: 변수 이름 앞에 `__`를 붙이면, 파이썬은 이 변수를 **private 변수**로 취급합니다. 이는 클래스 외부에서 `my_account.__balance` 와 같이 직접 접근하려고 하면 `AttributeError`를 발생시켜 데이터를 보호합니다. 이것이 캡슐화와 정보 은닉의 핵심입니다.

**2. `def deposit(self, amount):` (Setter 역할)**
-   이 메서드는 private 변수인 `__balance`를 변경할 수 있는 **유일한 통로**입니다.
-   그냥 값을 바꾸는 것뿐만 아니라, `if amount > 0:` 와 같이 **유효성 검사 로직**을 추가할 수 있습니다. 이를 통해 음수 금액이 입금되는 등의 잘못된 데이터 변경을 막을 수 있습니다.

**3. `def get_balance(self):` (Getter 역할)**
-   이 메서드는 private 변수인 `__balance`의 값을 **읽을 수 있는 유일한 통로**입니다.
-   외부에서는 이 메서드를 통해서만 잔액을 '조회'할 수 있고, 직접 '수정'하는 것은 불가능합니다.

---

#### 전체 코드 예시

```python
class BankAccount:
    def __init__(self, owner, balance=0):
        self.owner = owner
        # __balance는 private 변수로, 클래스 외부에서 직접 접근할 수 없습니다.
        self.__balance = balance
        print(f"{self.owner}님 계좌 개설. 초기 잔액: {self.__balance}원")

    # Setter 역할의 메서드: 안전하게 잔액을 변경합니다.
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"{amount}원 입금 완료. 현재 잔액: {self.__balance}원")
        else:
            print("입금액은 0보다 커야 합니다.")
    
    # Getter 역할의 메서드: 안전하게 잔액을 조회합니다.
    def get_balance(self):
        return self.__balance

# --- 실행 부분 ---
my_account = BankAccount("홍길동", 10000)

# 안전한 방법: 메서드를 통해 입금 및 조회
my_account.deposit(5000)
current_balance = my_account.get_balance()
print(f"현재 잔액 조회: {current_balance}원")

# 위험한 방법: private 변수에 직접 접근 시도
try:
    print(my_account.__balance)
except AttributeError as e:
    print(f"\n직접 접근 시도 실패: {e}")
```

### 📌 응용 실습 1: 직원 관리 시스템

**문제 목표**: `Employee` 클래스를 사용하여 여러 직원의 정보를 객체로 만들고 관리하는 프로그램을 작성합니다.

```python
class Employee:
    # __init__: 직원이 생성될 때 이름, 직책, 급여를 받아 객체의 속성으로 저장합니다.
    def __init__(self, name, position, salary):
        self.name = name
        self.position = position
        self.salary = salary
    
    # get_info: 객체가 가진 속성들을 조합하여 보기 좋은 형태로 출력합니다.
    def get_info(self):
        return f"이름: {self.name}, 직책: {self.position}, 급여: {self.salary}원"

# --- 실행 부분 ---
# Employee 클래스를 이용해 3명의 직원 객체 생성
emp1 = Employee("김철수", "개발자", 5000)
emp2 = Employee("이영희", "디자이너", 4500)
emp3 = Employee("박민준", "기획자", 5500)

# 각 직원의 정보를 출력
print(emp1.get_info())
print(emp2.get_info())
print(emp3.get_info())
```

### 📌 응용 실습 2: 도서 관리 시스템

**문제 목표**: 공통 부모 `Book` 클래스를 만들고, `EBook`과 `PaperBook`이 이를 상속받아 각자의 특성을 추가하며, 같은 `display_info` 호출에 다르게 반응하도록(다형성) 구현합니다.

```python
class Book:
    # 부모 클래스의 __init__: 모든 책이 공통으로 가지는 제목과 저자를 초기화합니다.
    def __init__(self, title, author):
        self.title = title
        self.author = author

    # 부모 클래스의 메서드: 공통 정보를 출력합니다.
    def display_info(self):
        print(f"제목: {self.title}, 저자: {self.author}", end="")

class EBook(Book):
    # 자식 클래스의 __init__: 부모에게 필요한 정보(title, author)와
    # 자신에게만 필요한 정보(file_size)를 함께 받습니다.
    def __init__(self, title, author, file_size):
        # super().__init__(): 부모 클래스의 __init__을 호출하여
        # title과 author 초기화를 부모에게 위임합니다. (코드 중복 방지)
        super().__init__(title, author)
        self.file_size = file_size

    # 메서드 오버라이딩: 부모의 기능을 확장합니다.
    def display_info(self):
        # super().display_info(): 부모의 display_info를 먼저 실행하여 공통 정보를 출력합니다.
        super().display_info()
        # 자식 클래스 고유의 정보를 추가로 출력합니다.
        print(f", 파일 크기: {self.file_size}MB")

class PaperBook(Book):
    def __init__(self, title, author, pages):
        super().__init__(title, author)
        self.pages = pages
    
    def display_info(self):
        super().display_info()
        print(f", 페이지 수: {self.pages}쪽")

# --- 실행 부분 ---
books = [
    EBook("파이썬 정복", "김작가", 10.5),
    PaperBook("자료구조 마스터", "이박사", 500)
]

# 다형성: 같은 book.display_info() 호출이지만,
# 객체가 EBook이냐 PaperBook이냐에 따라 다른 결과가 출력됩니다.
for book in books:
    book.display_info()
```

### 📌 응용 실습 3: 자동차 관리 시스템

**문제 목표**: 자동차의 연료(`fuel`)를 private 변수로 보호하고, `drive`와 `refuel` 메서드를 통해서만 안전하게 연료 상태를 변경하도록 캡슐화를 적용합니다.

```python
class Car:
    def __init__(self, model, initial_fuel=50):
        self.model = model
        # __fuel: private 변수로 선언하여 외부의 직접적인 수정을 방지합니다.
        self.__fuel = initial_fuel
        print(f"{self.model} 생성. 초기 연료: {self.__fuel}L")

    # Getter: private 변수인 __fuel을 안전하게 조회할 수 있는 통로입니다.
    def get_fuel(self):
        return self.__fuel

    # drive 메서드: 연료 상태를 변경하는 로직을 포함합니다.
    def drive(self, distance):
        # 연비: 10km당 1L 소모한다고 가정
        fuel_needed = distance / 10
        
        if self.__fuel >= fuel_needed:
            self.__fuel -= fuel_needed
            print(f"{distance}km 주행 완료. 남은 연료: {self.__fuel:.1f}L")
        else:
            print("연료 부족으로 주행할 수 없습니다.")

    # refuel 메서드: 연료 상태를 변경하는 또 다른 통로입니다.
    def refuel(self, amount):
        if amount > 0:
            self.__fuel += amount
            print(f"{amount}L 주유 완료. 현재 연료: {self.__fuel:.1f}L")
        else:
            print("주유량은 0보다 커야 합니다.")

# --- 실행 부분 ---
my_car = Car("소나타")

my_car.drive(200) # 20L 소모
my_car.refuel(30)  # 30L 주유
my_car.drive(700) # 연료 부족

# private 변수는 직접 수정 불가, 오직 메서드를 통해서만 상태 변경 가능
# my_car.__fuel = 1000 # (작동하지 않음)
print(f"최종 연료 상태: {my_car.get_fuel():.1f}L")
```