# Python 학습 가이드

## Chapter 03: 함수와 문자열

### 1. 함수 기초

#### 함수의 개념과 장점
- **함수(function)**: 어떤 일을 수행하는 코드의 덩어리, 또는 코드의 묶음
- **함수의 장점**:
  ① 필요할 때마다 호출 가능
  ② 논리적인 단위로 분할 가능
  ③ 코드의 캡슐화

#### 함수의 선언
```python
def 함수이름(매개변수):
    수행문
    return 반환값
```

- **def**: 'definition'의 줄임말로, 함수를 정의하여 시작한다는 의미
- **함수 이름**: 
  - 소문자로 입력, 띄어쓰기를 할 경우에는 _ 기호를 사용 (ex: save_model)
  - 행위를 기록하므로 동사와 명사를 함께 사용하는 경우가 많음 (ex: find_number)
  - 외부에 공개하는 함수일 경우, 줄임말을 사용하지 않고 짧고 명료한 이름 사용
- **매개변수(parameter)**: 함수에서 입력값으로 사용하는 변수
- **수행문**: 수행문은 반드시 들여쓰기한 후 코드를 입력

#### 프로그래밍의 함수와 수학의 함수
간단히 f(x) = x + 1을 코드로 나타낸다면:
```python
def f(x):
    return x + 1
```


//=============================


### 2. 함수 심화

#### 함수의 호출 방식
- **Call by Value**: 값에 의한 호출
- **Call by Object Reference**: 객체 참조에 의한 호출 (Python의 방식)

#### 변수의 사용 범위(Scoping Rule)
- **지역 변수(Local Variable)**: 함수 안에서만 사용
- **전역 변수(Global Variable)**: 프로그램 전체에서 사용

```python
# 전역 변수
global_var = 10

def function():
    # 지역 변수
    local_var = 20
    global global_var  # 전역 변수를 함수 내에서 수정할 때
    global_var = 30
```

#### 재귀 함수(Recursive Function)
함수가 자기 자신을 다시 부르는 함수

```python
def factorial(n):
    if n == 1:
        return 1
    else:
        return n * factorial(n-1)
```

**[심화] 재귀 함수 주의사항**:
- 반드시 종료 조건(base case)이 있어야 함
- 스택 오버플로우 위험성 있음
- Python은 기본적으로 재귀 깊이 제한이 1000


//=============================


### 3. 함수의 인수

#### 키워드 인수(Keyword Arguments)
함수에 입력되는 매개변수의 변수명을 사용하여 함수의 인수를 지정하는 방법

```python
def greet(name, age):
    print(f"안녕하세요, {name}님! {age}세이시군요.")

greet(age=25, name="홍길동")  # 순서를 바꿔도 가능
```

#### 디폴트 인수(Default Arguments)
매개변수에 기본값을 지정하여 사용

```python
def greet(name, greeting="안녕하세요"):
    print(f"{greeting}, {name}님!")

greet("홍길동")  # "안녕하세요, 홍길동님!"
greet("홍길동", "반갑습니다")  # "반갑습니다, 홍길동님!"
```

#### 가변 인수(Variable-length Arguments)
함수의 매개변수 개수가 정해지지 않고 사용하는 것

```python
def add_all(*args):
    return sum(args)

print(add_all(1, 2, 3, 4, 5))  # 15
```

- `*args`는 튜플(tuple) 자료형으로 함수 안에서 사용
- 가변인수는 일반적인 키워드 인수가 모두 끝난 후 사용

#### 키워드 가변 인수(Keyword Variable-length Arguments)
매개변수의 이름을 따로 지정하지 않고 입력하는 방법, `**`를 사용

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="홍길동", age=25, city="서울")
```

**[심화] 인수 순서 규칙**:
```python
def function(positional, *args, keyword=None, **kwargs):
    pass
```
순서: 일반 인수 → 가변 인수 → 키워드 인수 → 키워드 가변 인수


//=============================


### 4. 문자열의 이해

#### 문자열의 개념
- 문자열은 **시퀀스 자료형(Sequence Data Type)**
- 영문자 한 글자당 1바이트의 메모리 공간 사용
- 컴퓨터는 문자를 이진수로 변환하여 저장 (ASCII, UTF-8 등의 인코딩 방식 사용)

#### 문자열의 인덱싱과 슬라이싱
```python
text = "Python"
print(text[0])     # 'P'
print(text[-1])    # 'n'
print(text[1:4])   # 'yth'
print(text[:3])    # 'Pyt'
print(text[3:])    # 'hon'
```

#### 문자열의 연산과 함수
```python
text = "Hello World"

# 대소문자 변환
print(text.upper())      # 'HELLO WORLD'
print(text.lower())      # 'hello world'
print(text.title())      # 'Hello World'
print(text.capitalize()) # 'Hello world'

# 문자열 정보
print(text.count('l'))       # 3
print(text.isdigit())        # False
print(text.startswith('He')) # True
```

#### 문자열 표현과 특수문자
```python
# 특수문자 사용
text1 = 'It\'s a beautiful day'
text2 = "He said \"Hello\""

# 여러 줄 문자열
text3 = """첫 번째 줄
두 번째 줄
세 번째 줄"""

text4 = '''
여러 줄로
작성된 문자열
'''
```

**[심화] 문자열 이스케이프 시퀀스**:
- `\n`: 줄바꿈
- `\t`: 탭
- `\\`: 백슬래시
- `\"`: 큰따옴표
- `\'`: 작은따옴표
- `\r`: 캐리지 리턴


//=============================


### 5. 문자열 서식 지정

#### % 서식
```python
name = "홍길동"
age = 25
print("이름: %s, 나이: %d" % (name, age))
```

**변수의 자료형에 따른 서식**:
- `%s`: 문자열
- `%d`: 정수
- `%f`: 실수

#### format() 함수
```python
name = "홍길동"
age = 25
print("이름: {}, 나이: {}".format(name, age))
print("이름: {0}, 나이: {1}".format(name, age))
print("이름: {name}, 나이: {age}".format(name=name, age=age))
```

#### 패딩(Padding)
```python
# % 서식의 패딩
print("%10d" % 12)      # 우측 정렬
print("%-10d" % 12)     # 좌측 정렬
print("%10.3f" % 5.94343)  # 전체 10자리, 소수점 3자리

# format() 함수의 패딩
print("{:>10s}".format("Apple"))     # 우측 정렬
print("{:<10s}".format("Apple"))     # 좌측 정렬
print("{:^10s}".format("Apple"))     # 가운데 정렬
```

**[심화] f-string (Python 3.6+)**:
```python
name = "홍길동"
age = 25
print(f"이름: {name}, 나이: {age}")
print(f"계산 결과: {10 + 20}")
print(f"소수점 2자리: {3.141592:.2f}")
```


//=============================


## Chapter 04: 자료구조

### 1. 자료구조의 이해

#### 자료구조의 개념
- **자료구조(Data Structure)**: 특징이 있는 정보를 메모리에 효율적으로 저장 및 반환하는 방법
- 대용량 데이터일수록 메모리에 빨리 저장하고 빠르게 검색하여 메모리를 효율적으로 사용하고 실행 시간을 줄일 수 있음

#### 파이썬에서 제공하는 자료구조
- **리스트(List)**: 순서가 있는 가변 자료형
- **튜플(Tuple)**: 순서가 있는 불변 자료형
- **딕셔너리(Dictionary)**: 키-값 쌍의 자료형
- **세트(Set)**: 중복을 허용하지 않는 자료형


//=============================


### 2. 스택과 큐

#### 스택(Stack)
- **LIFO (Last In First Out)**: 마지막에 들어간 데이터가 가장 먼저 나옴
- **Push**: 데이터 저장
- **Pop**: 데이터 추출

```python
stack = []
stack.append(1)  # Push
stack.append(2)  # Push
stack.append(3)  # Push

print(stack.pop())  # 3 (Pop)
print(stack.pop())  # 2 (Pop)
print(stack)        # [1]
```

#### 큐(Queue)
- **FIFO (First In First Out)**: 먼저 들어간 데이터가 먼저 나옴

```python
from collections import deque

queue = deque()
queue.append(1)    # Enqueue
queue.append(2)    # Enqueue
queue.append(3)    # Enqueue

print(queue.popleft())  # 1 (Dequeue)
print(queue.popleft())  # 2 (Dequeue)
print(queue)            # deque([3])
```

**[심화] 파이썬에서 큐 구현 방법**:
1. `list.pop(0)` - 비효율적 (O(n))
2. `collections.deque` - 효율적 (O(1))
3. `queue.Queue` - 멀티스레딩 환경에서 안전


//=============================


### 3. 튜플과 세트

#### 튜플(Tuple)
- 리스트와 같은 개념이지만 **데이터를 변경할 수 없는** 자료구조
- 괄호 `()`를 사용하여 선언

```python
t = (1, 2, 3)
print(t[0])     # 1 (인덱싱 가능)
print(t[1:3])   # (2, 3) (슬라이싱 가능)
print(t + (4, 5))  # (1, 2, 3, 4, 5) (연산 가능)

# t[0] = 10  # 오류! 수정 불가능
```

**튜플 사용 시기**:
- 변경되지 않아야 하는 정보 (학번, 주민등록번호 등)
- 함수에서 여러 값을 반환할 때
- 딕셔너리의 키로 사용할 때

#### 세트(Set)
- 값을 **순서 없이** 저장하면서 **중복을 허용하지 않는** 자료형
- 중괄호 `{}`를 사용하거나 `set()` 함수 사용

```python
s = {1, 2, 3, 1, 2, 3}
print(s)  # {1, 2, 3} (중복 제거)

s.add(4)        # 원소 추가
s.remove(2)     # 원소 제거
s.discard(5)    # 원소 제거 (없어도 오류 없음)
s.update([6, 7, 8])  # 여러 원소 추가
```

#### 세트의 집합 연산
```python
A = {1, 2, 3, 4}
B = {3, 4, 5, 6}

print(A | B)  # {1, 2, 3, 4, 5, 6} (합집합)
print(A & B)  # {3, 4} (교집합)
print(A - B)  # {1, 2} (차집합)
print(A ^ B)  # {1, 2, 5, 6} (대칭차집합)
```

**[심화] 세트의 활용**:
```python
# 중복 제거
numbers = [1, 2, 2, 3, 3, 4]
unique_numbers = list(set(numbers))

# 멤버십 테스트 (매우 빠름 - O(1))
vowels = {'a', 'e', 'i', 'o', 'u'}
if 'a' in vowels:
    print("모음입니다")
```


//=============================


### 4. 딕셔너리

#### 딕셔너리의 개념
- **Key-Value** 형태로 데이터를 저장하는 자료구조
- 중괄호 `{}`를 사용하여 선언

```python
student_info = {
    "name": "홍길동",
    "age": 25,
    "major": "컴퓨터공학",
    "grade": "A+"
}

print(student_info["name"])  # "홍길동"
student_info["age"] = 26     # 값 수정
student_info["city"] = "서울"  # 새로운 키-값 추가
```

#### 딕셔너리의 함수
```python
country_code = {"Korea": 82, "USA": 1, "Japan": 81}

# 키, 값, 키-값 쌍 접근
print(country_code.keys())    # dict_keys(['Korea', 'USA', 'Japan'])
print(country_code.values())  # dict_values([82, 1, 81])
print(country_code.items())   # dict_items([('Korea', 82), ('USA', 1), ('Japan', 81)])

# for문과 함께 사용
for country, code in country_code.items():
    print(f"{country}: {code}")

# 키 존재 확인
if "Korea" in country_code:
    print("한국이 있습니다")
```

**[심화] 딕셔너리 메서드**:
```python
d = {"a": 1, "b": 2}

# get() - 키가 없어도 오류 없음
print(d.get("c", 0))  # 0 (기본값 반환)

# pop() - 키-값 제거하고 값 반환
value = d.pop("a")  # 1 반환, "a" 키 제거

# setdefault() - 키가 없으면 추가
d.setdefault("c", 3)  # {"b": 2, "c": 3}
```


//=============================


### 5. Collections 모듈

#### deque 모듈
스택과 큐를 모두 지원하는 모듈

```python
from collections import deque

deque_list = deque()
deque_list.append(1)      # 오른쪽에 추가
deque_list.appendleft(0)  # 왼쪽에 추가
print(deque_list)         # deque([0, 1])

deque_list.pop()          # 오른쪽에서 제거
deque_list.popleft()      # 왼쪽에서 제거

# rotate() 함수
dq = deque([1, 2, 3, 4])
dq.rotate(2)              # deque([3, 4, 1, 2])
```

#### Counter 모듈
시퀀스 자료형의 데이터 요소 개수를 딕셔너리 형태로 반환

```python
from collections import Counter

text = "gallahad"
c = Counter(text)
print(c)  # Counter({'a': 3, 'l': 2, 'g': 1, 'h': 1, 'd': 1})

# 가장 많이 나타나는 요소
print(c.most_common(2))  # [('a', 3), ('l', 2)]
```

#### defaultdict 모듈
딕셔너리의 변수를 생성할 때 키에 기본 값을 지정

```python
from collections import defaultdict

d = defaultdict(int)  # 기본값 0
d["first"] += 1       # 키가 없어도 기본값 0에서 시작
print(d["first"])     # 1
```

**[심화] Collections 모듈의 다른 자료구조**:
```python
from collections import OrderedDict, namedtuple

# OrderedDict - 순서를 기억하는 딕셔너리 (Python 3.7+에서는 일반 dict도 순서 유지)
od = OrderedDict([('a', 1), ('b', 2)])

# namedtuple - 이름이 있는 튜플
Point = namedtuple('Point', ['x', 'y'])
p = Point(1, 2)
print(p.x, p.y)  # 1 2
```


//=============================


## Chapter 05: 파이썬 스타일 코드

### 1. 파이썬 스타일 코드의 이해

#### 파이썬 스타일 코드(Pythonic Code)의 개념
- 파이썬에서 기본적으로 제공하는 문법들을 활용하여 코딩하는 기법
- 파이썬의 철학: "인간의 시간이 컴퓨터의 시간보다 더 중요하다"
- 코드를 간결하고 읽기 쉽게 만들며, 작성 시간을 줄임

```python
# 일반적인 방법
result = []
for i in range(10):
    result.append(i**2)

# 파이썬 스타일 코드
result = [i**2 for i in range(10)]
```


//=============================


### 2. 문자열의 분리 및 결합

#### split() 함수
문자열의 값을 특정 값을 기준으로 분리하여 리스트 형태로 변환

```python
text = "zero one two three"
words = text.split()      # ['zero', 'one', 'two', 'three']

text2 = "apple,banana,orange"
fruits = text2.split(",")  # ['apple', 'banana', 'orange']
```

#### join() 함수
문자열로 구성된 리스트를 합쳐 하나의 문자열로 반환

```python
colors = ["red", "green", "blue"]
result = " ".join(colors)    # "red green blue"
result2 = "-".join(colors)   # "red-green-blue"
result3 = "".join(colors)    # "redgreenblue"
```

**[심화] 문자열 처리 고급 기법**:
```python
# strip() - 공백 제거
text = "  hello world  "
print(text.strip())      # "hello world"
print(text.lstrip())     # "hello world  "
print(text.rstrip())     # "  hello world"

# replace() - 문자열 치환
text = "Hello World"
print(text.replace("World", "Python"))  # "Hello Python"
```


//=============================


### 3. 리스트 컴프리헨션

#### 기본 리스트 컴프리헨션
기존 리스트형을 사용하여 간단하게 새로운 리스트를 만드는 기법

```python
# 기본 형태
numbers = [i for i in range(10)]
squares = [i**2 for i in range(10)]
```

#### 필터링
if문과 함께 사용하는 리스트 컴프리헨션

```python
# 짝수만 추출
even_numbers = [i for i in range(10) if i % 2 == 0]

# 조건부 표현식 사용
result = [i if i % 2 == 0 else i*2 for i in range(10)]
```

#### 중첩 반복문
```python
# 일차원 리스트
word_1 = ["A", "B"]
word_2 = ["D", "E", "A"]
result = [i + j for i in word_1 for j in word_2]
# ['AD', 'AE', 'AA', 'BD', 'BE', 'BA']
```

#### 이차원 리스트
```python
# 이차원 리스트 생성
case_1 = ["A", "B", "C"]
case_2 = ["D", "E", "A"]
result = [[i + j for i in case_1] for j in case_2]
# [['AD', 'BD', 'CD'], ['AE', 'BE', 'CE'], ['AA', 'BA', 'CA']]
```

**[심화] 딕셔너리와 세트 컴프리헨션**:
```python
# 딕셔너리 컴프리헨션
squares_dict = {i: i**2 for i in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 세트 컴프리헨션
unique_squares = {i**2 for i in [-2, -1, 0, 1, 2]}
# {0, 1, 4}
```


//=============================


### 4. 다양한 방식의 리스트값 출력

#### enumerate() 함수
리스트값을 추출할 때 인덱스를 붙여 함께 출력

```python
fruits = ['apple', 'banana', 'orange']

for i, fruit in enumerate(fruits):
    print(f"{i}: {fruit}")
# 0: apple
# 1: banana
# 2: orange

# 딕셔너리로 변환
fruit_dict = {i: fruit for i, fruit in enumerate(fruits)}
```

#### zip() 함수
1개 이상의 리스트값이 같은 인덱스에 있을 때 병렬로 묶는 함수

```python
names = ['Alice', 'Bob', 'Charlie']
ages = [25, 30, 35]
cities = ['Seoul', 'Tokyo', 'London']

for name, age, city in zip(names, ages, cities):
    print(f"{name} ({age}) from {city}")

# 리스트의 합 구하기
a = [1, 2, 3]
b = [4, 5, 6]
sums = [x + y for x, y in zip(a, b)]  # [5, 7, 9]
```

**[심화] zip()의 고급 활용**:
```python
# 전치 행렬 만들기
matrix = [[1, 2, 3], [4, 5, 6]]
transposed = list(zip(*matrix))  # [(1, 4), (2, 5), (3, 6)]

# 두 리스트를 딕셔너리로
keys = ['a', 'b', 'c']
values = [1, 2, 3]
dictionary = dict(zip(keys, values))  # {'a': 1, 'b': 2, 'c': 3}
```


//=============================


### 5. 람다 함수

#### 람다 함수의 사용
함수의 이름 없이, 함수처럼 사용할 수 있는 익명의 함수

```python
# 일반 함수
def add(x, y):
    return x + y

# 람다 함수
add_lambda = lambda x, y: x + y

print(add(3, 5))        # 8
print(add_lambda(3, 5)) # 8
```

#### 람다 함수의 다양한 형태
```python
# 한 줄로 사용
print((lambda x: x + 1)(5))  # 6

# map()과 함께 사용
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9, 16, 25]

# filter()와 함께 사용
even_numbers = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]

# sorted()와 함께 사용
students = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]
sorted_students = sorted(students, key=lambda x: x[1])  # 점수로 정렬
```

**[심화] 고차 함수와 람다**:
```python
# reduce() 함수
from functools import reduce
numbers = [1, 2, 3, 4, 5]
sum_all = reduce(lambda x, y: x + y, numbers)  # 15

# 클로저 생성
def make_multiplier(n):
    return lambda x: x * n

multiply_by_3 = make_multiplier(3)
print(multiply_by_3(4))  # 12
```


//=============================


### 6. 별표의 활용

#### 별표의 사용
별표(asterisk, *)는 곱하기 기호이지만, 특별한 용도로도 사용

```python
# 함수의 가변 인수
def add_all(*args):
    return sum(args)

print(add_all(1, 2, 3, 4, 5))  # 15

# 키워드 가변 인수
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")

print_info(name="Alice", age=25)
```

#### 별표의 언패킹 기능
여러 개의 데이터를 담는 자료형에서 해당 데이터를 언패킹

```python
def asterisk_test(a, *args):
    print(a, *args)  # args를 언패킹하여 출력

asterisk_test(1, 2, 3, 4, 5, 6)  # 1 2 3 4 5 6

# 함수 호출 시 언패킹
data = [1, 2, 3, 4]
asterisk_test(*data)  # 1 2 3 4
```

#### zip()과 별표의 활용
```python
# 이차원 리스트에서 각 열의 평균 구하기
scores = [[85, 92, 78], [90, 88, 84], [92, 85, 90]]

for subject_scores in zip(*scores):
    print(f"평균: {sum(subject_scores) / len(subject_scores):.1f}")
```

**[심화] 별표 활용의 고급 사례**:
