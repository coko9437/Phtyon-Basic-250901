## Chapter 2: 기본 문법

### 1. 변수와 자료형

#### 변수명 선언 규칙
- 알파벳, 숫자, 밑줄( `_` )로 선언할 수 있으나, 숫자로 시작할 수 없습니다.
- 변수명은 의미 있는 단어로 표기하는 것이 좋습니다.
- 변수명은 대소문자가 구분됩니다 (`my_var`와 `My_Var`는 다른 변수입니다).
- 특별한 의미가 있는 예약어(예: `if`, `for`, `class`)는 사용할 수 없습니다.

#### 기본 자료형
- **정수형(Integer)**: 소수점이 없는 숫자 (예: `10`, `0`, `-5`)
- **실수형(Float)**: 소수점이 있는 숫자 (예: `3.14`, `-0.001`)
- **문자열형(String)**: 따옴표(`'`, `"`)로 묶인 텍스트 데이터 (예: `'Hello'`)
- **불린형(Boolean)**: 논리형으로, `True`(참) 또는 `False`(거짓)을 표현합니다.

#### 동적 타이핑 (Dynamic Typing)
- 변수의 자료형을 미리 선언하지 않고, 실행 시점에 할당되는 값에 따라 인터프리터가 자동으로 타입을 결정하는 방식입니다.
- C나 Java: `int data = 8;` 처럼 사전에 타입을 선언해야 합니다.
- 파이썬: `data = 8` 형태로 선언하면, 파이썬이 스스로 `data`가 정수형임을 판단합니다.

#### 기본 연산자
- **산술 연산**: `+`, `-`, `*`, `/`
- **제곱**: `**`
- **몫**: `//`
- **나머지**: `%`
- **할당 연산**: `+=`, `-=`

#### 관계 연산자 (비교 연산자)
| 연산자 | 의미 |
|---|---|
| `>` | 크다 |
| `<` | 작다 |
| `>=` | 크거나 같다 |
| `<=` | 작거나 같다 |
| `==` | 같다 |
| `!=` | 같지 않다 |

#### 논리 연산자
| 연산자 | 의미 |
|---|---|
| `and` | 그리고 (두 조건 모두 참일 때 True) |
| `or` | 또는 (두 조건 중 하나라도 참일 때 True) |
| `not` | 부정 (True를 False로, False를 True로) |

#### 자료형 변환 (Type Casting)
- **정수형 → 실수형**: `float()` 함수
- **실수형 → 정수형**: `int()` 함수 (소수점 이하 버림)
- **숫자형 → 문자열형**: `str()` 함수
- **자료형 확인**: `type()` 함수

### 2. 입출력 함수

#### 출력 함수: `print()`
```python
# 여러 값 출력
name = '홍길동'
age = 25
print('이름:', name, ', 나이:', age)```
#### 표준 입력 함수: `input()`
- 사용자로부터 키보드 입력을 받아 **문자열(string)** 형태로 반환합니다.
- 숫자 계산이 필요하면 반드시 `int()`나 `float()`로 형 변환을 해야 합니다.

### 3. 리스트 (List)

#### 리스트의 개념
- 여러 개의 값을 하나의 변수에 순서대로 저장하는 자료형입니다.
- 대괄호 `[]`로 감싸고, 각 값(요소)은 쉼표 `,`로 구분합니다.
- 다양한 자료형의 값을 함께 저장할 수 있습니다.

#### 인덱싱과 슬라이싱
- **인덱싱**: `my_list[0]` 처럼 특정 위치의 요소 하나에 접근합니다 (0부터 시작).
- **슬라이싱**: `my_list[1:4]` 처럼 특정 범위의 요소들을 잘라내어 새로운 리스트를 만듭니다.
- **리버스 인덱스**: `my_list[-1]` 처럼 맨 뒤에서부터 접근합니다 (-1부터 시작).
- **증가값(step)**: `my_list[::2]` 처럼 N칸씩 건너뛰며 요소를 가져옵니다.

#### 리스트 함수 및 연산
- **연결**: `+` 연산자로 두 리스트를 합칩니다.
- **반복**: `*` 연산자로 리스트를 여러 번 반복합니다.
- **포함 여부**: `in` 연산자로 특정 요소가 리스트에 있는지 확인합니다.
- **추가**: `append()` (맨 뒤에), `insert()` (특정 위치에)
- **삭제**: `remove()` (값을 지정), `del` (인덱스를 지정)

#### 패킹과 언패킹
- **패킹(Packing)**: `my_list = [1, 2, 3]` 처럼 하나의 변수에 여러 값을 담는 것.
- **언패킹(Unpacking)**: `a, b, c = my_list` 처럼 변수 속 값들을 여러 변수에 나누어 담는 것.

### 4. 조건문과 반복문

#### 조건문 (`if`, `elif`, `else`)
- 조건에 따라 다른 코드를 실행하도록 흐름을 제어합니다.

#### 반복문 (`for`, `while`)
- 특정 코드를 여러 번 반복해서 실행합니다.
- `range()`: `for`문과 함께 사용하여 원하는 횟수만큼 반복을 쉽게 만듭니다.
- **제어**: `break` (반복 중단), `continue` (이번 반복만 건너뛰기)

---

**🔥 심화 내용 1: `is` vs `==` (메모리 주소와 값의 비교)**
- `==`는 두 변수가 가리키는 **값**이 같은지를 비교합니다.
- `is`는 두 변수가 가리키는 **메모리 주소**가 같은지, 즉 완전히 동일한 객체인지를 비교합니다. 리스트와 같은 가변(mutable) 객체를 다룰 때 이 차이를 이해하는 것이 매우 중요합니다.
```python
a = [1, 2, 3]
b = [1, 2, 3] # 값은 같지만, 서로 다른 메모리 공간에 생성됨
c = a       # a가 가리키는 메모리 주소를 그대로 복사

print(f"a == b: {a == b}") # True (값이 같음)
print(f"a is b: {a is b}") # False (메모리 주소가 다름)
print(f"a is c: {a is c}") # True (메모리 주소가 같음)
```

**🔥 심화 내용 2: Truthy & Falsy (참과 거짓으로 취급되는 값들)**
파이썬에서는 `True`, `False` 외에도 참/거짓으로 판단되는 값들이 있습니다. 이를 활용하면 코드를 더 간결하게 만들 수 있습니다.
- **Falsy (거짓으로 취급)**: `0`, `""` (빈 문자열), `[]` (빈 리스트), `{}` (빈 딕셔너리), `None` 등
- **Truthy (참으로 취급)**: Falsy가 아닌 모든 값
```python
my_list = []
if my_list: # 빈 리스트는 False로 취급되므로 이 블록은 실행되지 않음
    print("리스트에 요소가 있습니다.")
else:
    print("리스트가 비어있습니다.")
```

**🔥 심화 내용 3: List Comprehension (리스트 내포)**
`for`문을 사용하여 리스트를 만드는 과정을 한 줄로 압축하여 더 빠르고 간결하게 작성하는 기법입니다.
```python
# 0부터 9까지의 짝수를 제곱하여 리스트 만들기

# 일반적인 방법
squares = []
for i in range(10):
    if i % 2 == 0:
        squares.append(i**2)

# 리스트 컴프리헨션
squares_comp = [i**2 for i in range(10) if i % 2 == 0]

print(squares_comp) # [0, 4, 16, 36, 64]
```
-----------
## Chapter 3: 함수와 문자열

### 1. 함수 기초

#### 함수의 개념과 장점
- **함수(Function)**: 특정 작업을 수행하는 코드의 묶음(덩어리).
- **장점**: 코드의 재사용, 모듈화를 통한 관리 용이성, 캡슐화.

#### 함수의 선언
```python
def 함수이름(매개변수1, 매개변수2):
    """Docstring: 이 함수는 어떤 일을 하는지 설명합니다."""
    # 수행할 코드
    result = 매개변수1 + 매개변수2
    return result # 결과를 반환
```

### 2. 함수 심화

#### 함수의 호출 방식: Call by Object Reference
- 파이썬은 함수에 인수를 전달할 때, 값이 아닌 **객체의 주소(reference)**를 전달합니다.
- 이로 인해 함수 안에서 리스트, 딕셔너리 같은 가변(mutable) 객체를 수정하면 원본 객체도 함께 변경됩니다.

#### 변수의 사용 범위 (Scoping Rule)
- **지역 변수(Local Variable)**: 함수 안에서 선언된 변수. 함수 밖에서는 접근할 수 없습니다.
- **전역 변수(Global Variable)**: 함수 밖에 선언된 변수. 코드 전체에서 접근 가능합니다. 함수 내에서 전역 변수 값을 수정하려면 `global` 키워드를 사용해야 합니다.

#### 재귀 함수 (Recursive Function)
- 함수가 자기 자신을 다시 호출하는 함수입니다. 반드시 종료 조건이 있어야 합니다.

### 3. 함수의 인수

#### 키워드 인수 (Keyword Arguments)
- `my_func(age=25, name="홍길동")` 처럼 매개변수 이름을 직접 지정하여 순서에 상관없이 인수를 전달하는 방식입니다.

#### 디폴트 인수 (Default Arguments)
- `def greet(name, msg="안녕하세요"):` 처럼 매개변수에 기본값을 설정하는 방식입니다. 함수 호출 시 해당 인수를 생략하면 기본값이 사용됩니다.

#### 가변 인수 (`*args`)
- 정해지지 않은 개수의 위치 인수를 **튜플(Tuple)** 형태로 받습니다.

#### 키워드 가변 인수 (`**kwargs`)
- 정해지지 않은 개수의 키워드 인수를 **딕셔너리(Dictionary)** 형태로 받습니다.

### 4. 문자열의 이해 및 서식 지정

#### 문자열의 특징
- **시퀀스(Sequence)**: 순서가 있는 데이터. 인덱싱, 슬라이싱이 가능합니다.
- **불변성(Immutable)**: 한 번 생성된 문자열의 내용은 변경할 수 없습니다. 수정하려면 새로운 문자열을 만들어야 합니다.

#### 주요 문자열 함수 (메서드)
- `upper()`, `lower()`: 대/소문자 변환
- `strip()`: 양쪽 끝의 공백 제거
- `split()`: 특정 문자를 기준으로 문자열을 나눠 리스트로 반환
- `replace(old, new)`: `old` 문자열을 `new` 문자열로 교체
- `join()`: 리스트의 문자열 요소들을 하나로 합침

#### 문자열 서식 지정
- **% 서식**: ` "이름: %s" % name ` (구식)
- **`format()` 함수**: ` "이름: {}".format(name) `
- **f-string**: ` f"이름: {name}" ` (Python 3.6+ 부터 지원, **가장 권장되는 방식**)

---
**🔥 심화 내용 1: 인수의 전달 순서 규칙**
함수 정의 시, 인수는 반드시 정해진 순서를 따라야 합니다.
`일반 인수` → `*args` → `키워드 전용 인수` → `**kwargs`
```python
def func(pos1, pos2, *args, kw_only1, kw_only2, **kwargs):
    # pos1, pos2: 일반 위치 인수
    # *args: 나머지 위치 인수들을 튜플로 받음
    # kw_only1, kw_only2: 반드시 키워드로만 전달해야 하는 인수
    # **kwargs: 나머지 키워드 인수들을 딕셔너리로 받음
    pass
```

**🔥 심화 내용 2: 가변 객체 vs 불변 객체와 함수**
- **불변(Immutable) 객체** (숫자, 문자열, 튜플)를 인수로 넘기면, 함수 내에서 값을 변경해도 원본은 절대 변하지 않습니다.
- **가변(Mutable) 객체** (리스트, 딕셔너리)를 인수로 넘기면, 함수 내에서 **메서드를 통해 내부 요소를 변경할 경우 원본 객체도 함께 변경됩니다.** 이는 객체의 주소값이 전달되기 때문입니다.
```python
def modify_list(items):
    items.append(100) # 원본 리스트를 직접 수정

my_list = [10, 20]
modify_list(my_list)
print(my_list) # [10, 20, 100] -> 원본이 변경됨!
```

**🔥 심화 내용 3: f-string의 고급 서식 지정**
f-string은 단순 변수 출력을 넘어 다양한 서식 지정이 가능합니다.
```python
pi = 3.141592
num = 123

print(f"소수점 둘째 자리까지: {pi:.2f}") # 출력: 3.14
print(f"10자리 확보 후 우측 정렬: {num:>10}") # 출력: '       123'
print(f"10자리 확보 후 0으로 채우기: {num:010}") # 출력: '0000000123'
print(f"천 단위 쉼표: {1000000:,}") # 출력: '1,000,000'
```
-----------
## Chapter 4: 자료구조

### 1. 스택과 큐

#### 스택 (Stack)
- **LIFO (Last-In, First-Out)**: 마지막에 들어온 데이터가 가장 먼저 나가는 구조.
- 파이썬 리스트의 `append()`(Push)와 `pop()`(Pop)으로 구현.

#### 큐 (Queue)
- **FIFO (First-In, First-Out)**: 먼저 들어온 데이터가 가장 먼저 나가는 구조.
- 리스트의 `pop(0)`은 비효율적이므로, `collections.deque` 사용을 권장.

### 2. 튜플과 세트

#### 튜플 (Tuple)
- 리스트와 유사하지만, **값을 변경할 수 없는(immutable)** 자료구조.
- 소괄호 `()`를 사용하여 선언.
- 변경되지 않아야 하는 데이터를 안전하게 관리할 때 사용.

#### 세트 (Set)
- **중복을 허용하지 않고**, **순서가 없는** 값들의 모음.
- 중괄호 `{}` 또는 `set()` 함수로 선언.
- **집합 연산**: 합집합(`|`), 교집합(`&`), 차집합(`-`) 등이 가능.

### 3. 딕셔너리 (Dictionary)

#### 딕셔너리의 개념
- **Key-Value 쌍**으로 데이터를 저장하는 자료구조.
- Key는 고유해야 하며, 불변(immutable) 객체만 사용 가능.
- 중괄호 `{}`를 사용하여 `{Key: Value}` 형태로 선언.

#### 딕셔너리 관련 함수 (메서드)
- `keys()`: 모든 Key를 모아 반환
- `values()`: 모든 Value를 모아 반환
- `items()`: (Key, Value) 쌍을 모아 반환

### 4. collections 모듈

#### `deque`
- 양쪽 끝에서 데이터를 빠르게 추가하거나 제거할 수 있는 양방향 큐. 스택과 큐의 기능을 모두 효율적으로 수행합니다.

#### `Counter`
- 시퀀스 자료형의 데이터 요소 개수를 세는 데 특화된 딕셔너리. `most_common()` 메서드가 유용합니다.

#### `defaultdict`
- 딕셔너리에 존재하지 않는 키를 조회할 때, `KeyError` 대신 지정된 기본값을 자동으로 생성해주는 딕셔너리.

---
**🔥 심화 내용 1: 딕셔너리 고급 메서드 (`get`, `setdefault`)**
- `get(key, default)`: 키로 값을 조회할 때, 키가 없으면 에러 대신 `default` 값(지정하지 않으면 `None`)을 반환합니다. `if key in dict:` 검사를 줄여줍니다.
- `setdefault(key, default)`: `get`과 유사하지만, 키가 없을 경우 `default` 값을 반환할 뿐만 아니라, 그 키와 값으로 딕셔너리에 실제로 추가까지 해줍니다.
```python
my_dict = {'a': 1}
print(my_dict.get('b', 0)) # 0 (my_dict는 그대로 {'a': 1})

my_dict.setdefault('c', 3)
print(my_dict) # {'a': 1, 'c': 3} (딕셔너리가 변경됨)
```

**🔥 심화 내용 2: 해시(Hash)와 딕셔너리/세트의 시간 복잡도**
딕셔너리의 키와 세트의 요소는 **해시 가능(hashable)**해야 합니다. 파이썬은 내부적으로 해시 테이블을 사용하여 데이터를 저장하기 때문에, 키나 요소를 조회/추가/삭제하는 연산이 평균적으로 **O(1)**의 매우 빠른 시간 복잡도를 가집니다. 이는 데이터 양이 아무리 많아져도 연산 속도가 거의 일정하다는 의미입니다. 리스트에서 값을 찾는 시간 복잡도 O(n)과 비교하면 엄청난 장점입니다.

**🔥 심화 내용 3: `namedtuple` (이름을 가진 튜플)**
`collections` 모듈의 `namedtuple`은 튜플의 각 위치에 이름을 부여하여, 인덱스뿐만 아니라 이름으로도 데이터에 접근할 수 있게 해줍니다. 코드의 가독성을 크게 향상시킵니다.
```python
from collections import namedtuple

# 'Point'라는 이름의 namedtuple을 정의. 필드는 'x'와 'y'
Point = namedtuple('Point', ['x', 'y'])
p = Point(11, y=22)

print(p.x, p.y) # 11 22 (이름으로 접근)
print(p[0], p[1]) # 11 22 (인덱스로도 접근 가능)
```
-----------
## Chapter 5: 파이썬 스타일 코드 (Pythonic Code)

### 1. `split()` 과 `join()`
- `split()`: 문자열을 특정 구분자를 기준으로 쪼개 리스트로 만듭니다.
- `join()`: 리스트에 있는 문자열들을 하나의 문자열로 합칩니다.

### 2. 리스트 컴프리헨션
- `for`문과 `if`문을 한 줄에 압축하여 새로운 리스트를 생성하는 간결하고 빠른 방법입니다.

### 3. `enumerate()` 와 `zip()`
- `enumerate()`: 반복문에서 아이템의 인덱스와 값을 동시에 가져옵니다.
- `zip()`: 여러 개의 리스트(iterable)를 같은 인덱스끼리 짝지어 줍니다.

### 4. 람다 함수 (`lambda`)
- `lambda 매개변수: 표현식` 형태로 작성하는 이름 없는 한 줄짜리 함수입니다. `map`, `filter`, `sorted` 등의 인자로 유용하게 사용됩니다.

### 5. 별표의 활용 (`*`)
- 함수 정의 시 `*args` (가변 인수)나 `**kwargs` (키워드 가변 인수)로 사용됩니다.
- 함수 호출 시 리스트나 튜플 앞에 붙여 **언패킹(Unpacking)**하는 용도로 사용됩니다. `my_func(*my_list)`

---
**🔥 심화 내용 1: 제너레이터 표현식 (Generator Expressions)**
리스트 컴프리헨션과 문법이 거의 같지만, 대괄호 `[]` 대신 소괄호 `()`를 사용합니다.
- 리스트 컴프리헨션: 모든 값을 메모리에 올려놓고 리스트를 생성.
- 제너레이터 표현식: 값을 필요할 때마다 하나씩 계산하여 생성. 대용량 데이터를 처리할 때 메모리를 매우 효율적으로 사용할 수 있습니다.
```python
# 1GB의 메모리를 차지하는 리스트를 만드는 대신,
# 필요할 때마다 값을 생성하는 제너레이터
large_data_gen = (i for i in range(100000000))

# for문 등에서 사용할 때 하나씩 값을 만들어냄
total = sum(large_data_gen)
```

**🔥 심화 내용 2: `zip(*matrix)`를 이용한 2차원 리스트의 행과 열 바꾸기**
`zip()`과 언패킹(`*`)을 조합하면 2차원 리스트의 행과 열을 바꾸는(전치 행렬) 작업을 매우 간결하게 처리할 수 있습니다.
```python
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

transposed = list(zip(*matrix))
print(transposed) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]```

**🔥 심화 내용 3: 딕셔너리와 세트 컴프리헨션**
리스트 컴프리헨션과 동일한 문법을 `{}`와 함께 사용하여 딕셔너리와 세트도 간결하게 생성할 수 있습니다.
```python
# 딕셔너리 컴프리헨션
my_dict = {i: i**2 for i in range(5)}
# {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# 세트 컴프리헨션
my_set = {s for s in 'hello'}
# {'h', 'e', 'l', 'o'}
```
-----------
## Chapter 6: 객체 지향 프로그래밍 (OOP)

### 1. 클래스와 객체
- **클래스(Class)**: 객체를 만들기 위한 '설계도' 또는 '틀'.
- **객체(Object/Instance)**: 클래스로부터 생성된 실체. 메모리에 할당된 것을 의미.
- **`__init__(self, ...)`**: 생성자. 객체가 생성될 때 속성을 초기화하는 특별한 메서드. `self`는 생성된 객체 자신을 가리킵니다.
- **메서드(Method)**: 클래스 내에 정의된 함수. 객체의 행동을 정의.

### 2. OOP의 핵심 특징
- **상속(Inheritance)**: 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용하고 확장하는 기능.
- **다형성(Polymorphism)**: 같은 이름의 메서드라도 객체에 따라 다르게 동작하는 것.
- **캡슐화(Encapsulation) / 정보 은닉**: 객체의 내부 데이터와 구현을 외부로부터 숨기고, 허용된 메서드를 통해서만 접근하게 하는 것. 파이썬에서는 변수나 메서드 이름 앞에 `_`나 `__`를 붙여 표현.

---
**🔥 심화 내용 1: 매직 메서드 (Magic Methods / Dunder Methods)**
`__init__`, `__str__`처럼 이름 앞뒤에 더블 언더스코어(`__`)가 붙은 특별한 메서드들. 특정 구문이나 내장 함수가 사용될 때 파이썬에 의해 자동으로 호출됩니다.
- `__str__(self)`: `print(obj)`나 `str(obj)` 호출 시 객체를 어떻게 문자열로 표현할지 정의. 사용자 친화적.
- `__repr__(self)`: `repr(obj)` 호출 시나 인터프리터에서 객체를 그냥 입력했을 때 어떻게 표현될지 정의. 개발자 친화적, 명확한 표현.
- `__len__(self)`: `len(obj)` 호출 시 객체의 길이를 반환하도록 정의.
- `__eq__(self, other)`: `obj1 == obj2` 비교 연산이 어떻게 동작할지 정의.

**🔥 심화 내용 2: `@property` 데코레이터 (Pythonic Getter & Setter)**
클래스 외부에서 속성에 직접 접근하는 것처럼 보이게 하면서도, 내부적으로는 메서드를 통해 값을 가져오거나 설정하는 로직을 실행하게 만드는 기능. 캡슐화를 유지하면서도 사용하기 편리한 인터페이스를 제공합니다.
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius # 내부적으로 사용할 변수

    @property
    def radius(self):
        """반지름 getter"""
        return self._radius

    @radius.setter
    def radius(self, value):
        """반지름 setter"""
        if value <= 0:
            raise ValueError("반지름은 0보다 커야 합니다.")
        self._radius = value

c = Circle(5)
print(c.radius) # 메서드지만 () 없이 속성처럼 접근
c.radius = 10   # setter 메서드 호출
```

**🔥 심화 내용 3: `super()`를 이용한 부모 클래스 메서드 호출**
자식 클래스에서 부모 클래스의 메서드를 재정의(override)했을 때, 재정의된 메서드 안에서 원래의 부모 메서드를 호출하고 싶을 때 `super()`를 사용합니다. 상속 구조를 명확하고 유지보수하기 쉽게 만들어줍니다.
```python
class Parent:
    def __init__(self, name):
        self.name = name

class Child(Parent):
    def __init__(self, name, age):
        super().__init__(name) # Parent.__init__(self, name)과 같음
        self.age = age
```
-----------
## Chapter 7: 데이터 분석 라이브러리

### 1. NumPy
- 다차원 배열(ndarray) 객체를 중심으로, 벡터 및 행렬 연산을 위한 강력한 기능을 제공하는 라이브러리. 데이터 분석의 기반이 됩니다.

### 2. Pandas
- 행과 열로 이루어진 표 형태의 데이터(DataFrame)를 다루는 데 특화된 라이브러리. 데이터 정제, 처리, 분석에 필수적입니다.
- **Series**: 1차원 배열 (인덱스를 가짐)
- **DataFrame**: 2차원 배열 (행과 열 인덱스를 가짐)

### 3. Matplotlib
- 데이터를 다양한 종류의 그래프(선, 막대, 산점도 등)로 시각화하는 라이브러리. 분석 결과를 직관적으로 이해하도록 돕습니다.

---
**🔥 심화 내용 1: NumPy의 브로드캐스팅 (Broadcasting)**
서로 크기(shape)가 다른 배열 간에도 산술 연산을 가능하게 해주는 강력한 기능. `for`문을 사용하지 않고도 모든 요소에 연산을 적용할 수 있어 코드가 간결해지고 실행 속도가 매우 빨라집니다.```python
import numpy as np

arr = np.array([[1, 2, 3], [4, 5, 6]]) # (2, 3) shape
scalar = 10

result = arr + scalar # 각 요소에 10이 더해짐
# [[11, 12, 13],
#  [14, 15, 16]]
```

**🔥 심화 내용 2: Pandas의 `loc` vs `iloc`**
DataFrame에서 데이터를 선택하는 가장 중요한 방법입니다.
- **`.loc[]` (Label-based)**: **이름(label)** 기반으로 행과 열을 선택합니다. `df.loc['row_name', 'col_name']`
- **`.iloc[]` (Integer-based)**: **정수 위치(integer position)** 기반으로 행과 열을 선택합니다. `df.iloc[0, 1]`
슬라이싱 시 `loc`은 끝 인덱스를 포함하지만, `iloc`은 포함하지 않는다는 차이점도 중요합니다.

**🔥 심화 내용 3: Pandas의 `groupby` (Split-Apply-Combine)**
데이터를 특정 기준에 따라 여러 그룹으로 나누고(Split), 각 그룹에 함수를 적용한 뒤(Apply), 그 결과들을 다시 하나로 합치는(Combine) 강력한 데이터 집계 기능입니다.
```python
import pandas as pd
# '팀'별 '점수'의 평균 구하기
df = pd.DataFrame({'팀': ['A', 'B', 'A', 'B'], '선수': [...], '점수': [10, 20, 15, 25]})
team_mean_score = df.groupby('팀')['점수'].mean()
print(team_mean_score)
```
-----------
## Chapter 8: 데이터베이스

### 1. 관계형 데이터베이스 (RDBMS)
- 데이터를 정해진 스키마에 따라 테이블 형태로 저장하고 관리하는 시스템. SQL(Structured Query Language)을 사용하여 데이터를 조작합니다.
- **SQLite**: 서버 없이 파일 하나로 데이터베이스를 관리하는 경량 DB.
- **Oracle, MySQL**: 대규모 서비스를 위한 강력한 기능을 갖춘 서버 기반 DB.

### 2. Python DB 연동 기본 과정
1. **`connect()`**: 데이터베이스에 연결.
2. **`cursor()`**: SQL 문장을 실행하고 결과를 가져올 커서를 생성.
3. **`execute()`**: 커서를 통해 SQL 문장을 실행.
4. **`fetchall()`, `fetchone()`, `fetchmany()`**: 조회(SELECT) 결과를 가져옴.
5. **`commit()`**: 데이터 변경(INSERT, UPDATE, DELETE) 사항을 최종 반영.
6. **`close()`**: 커서와 연결을 닫아 자원을 해제.

---
**🔥 심화 내용 1: SQL Injection 방지와 매개변수 바인딩**
SQL 쿼리 문자열에 사용자 입력을 직접 합치는 것은 SQL Injection 공격에 매우 취약합니다. DB-API는 이를 방지하기 위해 **매개변수 바인딩(Parameter Binding)** 기능을 제공합니다. 쿼리 템플릿에 `?` 또는 `:name` 같은 플레이스홀더를 사용하고, 실제 값은 `execute()` 메서드의 두 번째 인자로 전달해야 합니다.
```python
# 절대 이렇게 사용하면 안 됨! (SQL Injection 위험)
# cursor.execute(f"SELECT * FROM users WHERE username = '{user_input}'")

# 올바른 방법 (매개변수 바인딩)
sql = "SELECT * FROM users WHERE username = ?"
cursor.execute(sql, (user_input,))
```

**🔥 심화 내용 2: `with` 구문을 이용한 자원 자동 관리**
`connect()`와 `cursor()` 객체는 `with` 구문과 함께 사용할 수 있습니다. `with` 블록이 끝나면 `.close()` 메서드가 자동으로 호출되므로, 예외 발생 여부와 상관없이 항상 안전하게 자원을 해제할 수 있습니다.
```python
import sqlite3

with sqlite3.connect('my_db.db') as conn:
    with conn.cursor() as cursor:
        cursor.execute("SELECT * FROM my_table")
        for row in cursor.fetchall():
            print(row)
# with 블록이 끝나면 cursor와 conn이 자동으로 닫힘```

**🔥 심화 내용 3: Pandas와 데이터베이스 연동**
Pandas는 데이터베이스와 데이터를 쉽게 주고받을 수 있는 강력한 기능을 제공합니다.
- **`pd.read_sql(sql, conn)`**: SQL 조회 결과를 바로 DataFrame으로 가져옵니다.
- **`df.to_sql(table_name, conn)`**: DataFrame의 데이터를 데이터베이스 테이블에 저장합니다.
```python
import pandas as pd
import sqlite3

with sqlite3.connect('my_db.db') as conn:
    # DB 테이블을 DataFrame으로 읽기
    df = pd.read_sql("SELECT * FROM my_table", conn)

    # DataFrame을 DB 테이블로 쓰기
    df.to_sql('new_table', conn, if_exists='replace', index=False)
```