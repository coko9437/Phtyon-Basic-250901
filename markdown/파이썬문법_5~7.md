# 파이썬 학습 가이드

## Chapter 1: 파이썬 스타일 코딩

### 1-1. 파이썬 스타일 코드의 이해

**파이썬 스타일 코드(Pythonic Code)**란 파이썬의 고유한 문법과 특징을 활용하여 간결하고 효율적으로 작성하는 코드를 의미합니다.

파이썬의 철학: "인간의 시간이 컴퓨터의 시간보다 더 중요하다"

- 코드 작성 시간 단축
- 코드의 간결성 향상
- 가독성 증대
- 유지보수 용이성

**전통적인 방식 vs 파이썬 스타일**
```python
# 전통적인 방식
result = ""
words = ["hello", "world", "python"]
for word in words:
    result += word + " "

# 파이썬 스타일
words = ["hello", "world", "python"]
result = " ".join(words)
```

**심화 내용:**
- PEP 8: 파이썬 공식 코딩 스타일 가이드
- The Zen of Python (import this로 확인 가능)
- 코드 리뷰 시 pythonic 코드의 중요성


### 1-2. 문자열의 분리 및 결합

**split() 함수**
문자열을 특정 값을 기준으로 분리하여 리스트로 변환합니다.

```python
text = "zero one two three"
words = text.split()  # 공백 기준 분리
print(words)  # ['zero', 'one', 'two', 'three']

# 특정 구분자로 분리
data = "apple,banana,orange"
fruits = data.split(',')
print(fruits)  # ['apple', 'banana', 'orange']
```

**join() 함수**
문자열 리스트를 하나의 문자열로 결합합니다.

```python
colors = ['red', 'blue', 'green']
result = "".join(colors)  # redbluegreen
result_comma = ",".join(colors)  # red,blue,green
result_dash = "-".join(colors)  # red-blue-green
```

**심화 내용:**
- rsplit(): 오른쪽부터 분리 (maxsplit 매개변수 활용)
- partition(): 첫 번째 구분자만으로 3개 부분으로 분리
- join()의 성능: + 연산자보다 훨씬 빠름


//=============================


### 1-3. 리스트 컴프리헨션

**기본 개념**
기존 리스트를 사용하여 새로운 리스트를 간단하게 만드는 기법입니다.

```python
# 기존 방식
result = []
for i in range(10):
    result.append(i**2)

# 리스트 컴프리헨션
result = [i**2 for i in range(10)]
```

**필터링과 함께 사용**
```python
# 짝수만 저장
even_numbers = [i for i in range(10) if i % 2 == 0]

# 조건문과 else 사용
numbers = [i if i % 2 == 0 else i*2 for i in range(10)]
```

**중첩 반복문**
```python
word_1 = ['A', 'B', 'C']
word_2 = ['D', 'E', 'F']
result = [i + j for i in word_1 for j in word_2]
# ['AD', 'AE', 'AF', 'BD', 'BE', 'BF', 'CD', 'CE', 'CF']
```

**이차원 리스트**
```python
sentence = "The quick brown fox"
words = sentence.split()
result = [[word.upper(), word.lower(), len(word)] for word in words]
```

**심화 내용:**
- 딕셔너리 컴프리헨션: {key: value for item in iterable}
- 셋 컴프리헨션: {expression for item in iterable}
- 제너레이터 표현식: (expression for item in iterable)
- 메모리 효율성: 큰 데이터셋에서는 제너레이터 사용 권장


### 1-4. 다양한 방식의 리스트값 출력

**enumerate() 함수**
리스트 값을 추출할 때 인덱스를 함께 출력합니다.

```python
my_list = ['tic', 'tac', 'toe']
for index, value in enumerate(my_list):
    print(f"{index}: {value}")

# 딕셔너리로 변환
list_dict = {index: value for index, value in enumerate(my_list)}
```

**zip() 함수**
1개 이상의 리스트를 병렬로 묶는 함수입니다.

```python
alist = ['a1', 'a2', 'a3']
blist = ['b1', 'b2', 'b3']
for a, b in zip(alist, blist):
    print(f"{a}, {b}")

# 같은 위치 값들의 합계
numbers1 = [1, 2, 3, 4]
numbers2 = [5, 6, 7, 8]
sums = [sum(pair) for pair in zip(numbers1, numbers2)]
```

**enumerate와 zip 함께 사용**
```python
for index, (a, b) in enumerate(zip(alist, blist)):
    print(f"{index}: {a}, {b}")
```

**심화 내용:**
- zip_longest(): 길이가 다른 이터러블 처리
- enumerate의 start 매개변수 활용
- itertools.zip_longest의 fillvalue 매개변수


//=============================


### 1-5. 람다 함수

**람다 함수 기본 개념**
함수의 이름 없이 사용할 수 있는 익명 함수입니다.

```python
# 일반 함수
def add(x, y):
    return x + y

# 람다 함수
add_lambda = lambda x, y: x + y
result = add_lambda(2, 3)  # 5
```

**람다 함수의 다양한 형태**
```python
# 단일 매개변수
square = lambda x: x**2

# 조건문 포함
max_val = lambda x, y: x if x > y else y

# 즉시 실행
result = (lambda x, y: x * y)(3, 4)  # 12
```

**람다 함수와 내장 함수**
```python
numbers = [1, 2, 3, 4, 5]

# map과 함께
squared = list(map(lambda x: x**2, numbers))

# filter와 함께
evens = list(filter(lambda x: x % 2 == 0, numbers))

# sorted와 함께
students = [('Alice', 85), ('Bob', 90), ('Charlie', 78)]
sorted_by_grade = sorted(students, key=lambda x: x[1])
```

**심화 내용:**
- 람다는 한 줄로만 작성 가능
- 복잡한 로직은 일반 함수 사용 권장
- 클로저(closure)와 람다의 관계
- functools.partial과의 비교


### 1-6. 별표 활용

**가변 인수 (*args)**
여러 개의 인수를 하나의 매개변수로 받습니다.

```python
def asterisk_test(*args):
    print(args)
    print(type(args))

asterisk_test(1, 2, 3, 4, 5)  # (1, 2, 3, 4, 5) <class 'tuple'>
```

**키워드 가변 인수 (**kwargs)**
```python
def kwargs_test(**kwargs):
    print(kwargs)
    print(type(kwargs))

kwargs_test(name="John", age=30)  # {'name': 'John', 'age': 30} <class 'dict'>
```

**언패킹 기능**
```python
def asterisk_test(a, *args):
    print(a)
    print(*args)  # 언패킹하여 출력

asterisk_test(1, 2, 3, 4, 5, 6)
# 1
# 2 3 4 5 6
```

**zip과 별표 활용**
```python
scores = [[100, 90, 80], [85, 95, 75], [90, 85, 95]]
math_scores, eng_scores, sci_scores = zip(*scores)
print(f"Math average: {sum(math_scores)/len(math_scores)}")
```

**딕셔너리 언패킹**
```python
def function(name, age, city):
    print(f"Name: {name}, Age: {age}, City: {city}")

data = {"name": "Alice", "age": 25, "city": "Seoul"}
function(**data)
```

**심화 내용:**
- *를 이용한 리스트/튜플 언패킹의 다양한 활용
- **를 이용한 딕셔너리 병합
- 함수 시그니처에서 *와 **의 순서 규칙
- Python 3.8+ positional-only parameters (/)


//=============================


## Chapter 2: 객체지향 프로그래밍

### 2-1. 객체 지향 프로그래밍의 이해

**객체와 클래스의 개념**
- **객체(Object)**: 실제 존재하는 것들을 프로그래밍으로 표현한 것
- **클래스(Class)**: 객체가 가져야 할 기본 정보를 담은 설계도
- **인스턴스(Instance)**: 클래스로부터 실제로 생성된 객체

**객체의 구성 요소**
- **속성(Attribute)**: 객체의 특성이나 상태
- **메서드(Method)**: 객체의 행동이나 기능

**파이썬의 작명 기법**
- **카멜 케이스**: MyClass, myVariable
- **스네이크 케이스**: my_function, user_name
- **파스칼 케이스**: ClassName (클래스명에 주로 사용)

**심화 내용:**
- 모든 것이 객체인 파이썬의 특성
- 클래스와 인스턴스의 메모리 구조
- 클래스 변수 vs 인스턴스 변수의 차이점


### 2-2. 파이썬의 객체 지향 프로그래밍

**클래스 구현하기**
```python
class SoccerPlayer:
    def __init__(self, name, position, back_number):
        self.name = name
        self.position = position
        self.back_number = back_number
    
    def change_back_number(self, new_number):
        print(f"등번호 변경: {self.back_number} → {new_number}")
        self.back_number = new_number
    
    def __str__(self):
        return f"축구선수: {self.name} (포지션: {self.position}, 등번호: {self.back_number})"
```

**언더스코어(_)의 용도**
- `_`: 사용하지 않을 변수명 (관례)
- `__variable`: 프라이빗 변수 (name mangling)
- `__method__`: 특수 메서드 (매직 메서드)

**인스턴스 사용하기**
```python
jinhyun = SoccerPlayer("Jinhyun", "MF", 10)
print(jinhyun.name)  # Jinhyun
jinhyun.change_back_number(5)
print(jinhyun)  # __str__ 메서드 호출
```

**심화 내용:**
- `__new__` vs `__init__`의 차이점
- 클래스 메서드(@classmethod)와 정적 메서드(@staticmethod)
- property descriptor의 활용


### 2-3. 객체 지향 프로그래밍의 특징

**상속(Inheritance)**
부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 사용하는 것입니다.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def about_me(self):
        return f"저는 {self.name}이고, {self.age}살입니다."

class Employee(Person):
    def __init__(self, name, age, salary, company):
        super().__init__(name, age)  # 부모 클래스 생성자 호출
        self.salary = salary
        self.company = company
    
    def about_me(self):  # 메서드 오버라이딩
        return f"{super().about_me()} {self.company}에서 일하며 연봉은 {self.salary}입니다."
```

**다형성(Polymorphism)**
같은 이름의 메서드가 다른 기능을 하도록 하는 것입니다.

```python
class Animal:
    def talk(self):
        raise NotImplementedError("하위 클래스에서 구현해야 합니다.")

class Cat(Animal):
    def talk(self):
        return "야옹"

class Dog(Animal):
    def talk(self):
        return "멍멍"

# 다형성 활용
animals = [Cat(), Dog(), Cat()]
for animal in animals:
    print(animal.talk())  # 각각 다른 소리
```

**가시성(Visibility) / 캡슐화(Encapsulation)**
객체의 정보 접근을 제어하여 데이터를 보호합니다.

```python
class Product:
    def __init__(self):
        self.__items = []  # private 변수
    
    def add_item(self, item):
        self.__items.append(item)
    
    @property
    def items(self):  # getter 메서드
        return self.__items
    
    @items.setter
    def items(self, value):  # setter 메서드
        self.__items = value
```

**심화 내용:**
- 다중 상속과 MRO(Method Resolution Order)
- 추상 클래스(ABC)와 인터페이스 개념
- 데코레이터를 활용한 프로퍼티 설계
- 컴포지션 vs 상속의 선택 기준
- SOLID 원칙의 적용
- 디자인 패턴(싱글톤, 팩토리 등)의 구현


//=============================


## 추가 학습 팁

### 코딩 스타일 개선 방법
1. **코드 리뷰**: 동료와 함께 코드를 검토하며 개선점 찾기
2. **도구 활용**: pylint, black, isort 등의 도구 사용
3. **문서화**: docstring을 활용한 함수/클래스 설명 작성

### 객체지향 설계 원칙
1. **단일 책임 원칙**: 클래스는 하나의 책임만 가져야 함
2. **개방-폐쇄 원칙**: 확장에는 열려있고 수정에는 닫혀있어야 함
3. **의존성 역전 원칙**: 추상화에 의존하고 구체화에 의존하지 말 것

### 실습 프로젝트 아이디어
- 도서 관리 시스템 (상속과 다형성 활용)
- 간단한 게임 캐릭터 시스템 (클래스 설계 연습)
- 계산기 클래스 (메서드와 프로퍼티 활용)

이 가이드를 통해 파이썬의 고급 기능들을 체계적으로 학습하고, 
실제 프로젝트에서 효율적이고 유지보수가 용이한 코드를 작성할 수 있게 되기를 바랍니다.


//=============================


## Chapter 3: 파이썬 데이터 분석 라이브러리

### 3-1. 데이터 분석 라이브러리 개요

**주요 데이터 분석 라이브러리**

**NumPy (Numerical Python)**
- Python 데이터분석의 기본적인 기능 제공
- 벡터 및 행렬 연산과 관련된 편리한 기능 제공
- 정적 메모리 할당으로 빠른 연산 처리
- 딥러닝 프레임워크의 기반 라이브러리

**Pandas (Panel Data)**
- Series, DataFrame 등의 자료 구조 활용
- 대량의 데이터를 빠른 속도로 처리 가능
- 데이터 조작, 정제, 변환에 특화
- CSV, Excel, JSON 등 다양한 파일 형식 지원

**Matplotlib**
- 데이터 분석 결과의 시각화 도구
- 빠르고 직관적인 그래프 생성
- 다양한 플롯 스타일과 커스터마이징 옵션

**라이브러리 설치 및 기본 사용**
```python
# 라이브러리 설치
# pip install numpy pandas matplotlib

# 라이브러리 import
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

# Jupyter Notebook에서 그래프 출력 설정
%matplotlib inline

# 50개 난수 생성 예제
data = np.random.rand(50)
print(type(data))
print(data[:5])  # 처음 5개만 출력
```

**심화 내용:**
- Anaconda 패키지 관리자를 통한 환경 설정
- 가상환경에서의 라이브러리 관리
- Jupyter Notebook vs JupyterLab 선택 기준
- 메모리 효율적인 데이터 처리 방법


### 3-2. NumPy 라이브러리

**NumPy 기본 개념**
- 벡터 및 행렬 연산에 특화된 라이브러리
- array 단위로 데이터를 관리 (행렬과 유사)
- 동적 리스트와 달리 정적 메모리 할당
- 딥러닝 프레임워크(TensorFlow 등)에서 효과적 활용

**NumPy 배열 생성**
```python
import numpy as np

# 리스트에서 배열 생성
x = np.array([1, 3, 5, 7, 9])
print(x.shape)  # (5,) - 1행 5열

# 다양한 배열 생성 방법
zeros_array = np.zeros(5)        # 0으로 채우기
ones_array = np.ones((3, 4))     # 1로 채우기
range_array = np.arange(0, 10, 2) # 등간격 배열
random_array = np.random.rand(3, 3) # 랜덤 배열

# 배열 정보 확인
print(f"Shape: {x.shape}")       # 배열 형태
print(f"Size: {x.size}")         # 전체 원소 개수
print(f"Dtype: {x.dtype}")       # 데이터 타입
```

**배열 슬라이싱과 인덱싱**
```python
# 1차원 배열 슬라이싱
arr = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
print(arr[2:7])      # [2 3 4 5 6]
print(arr[::2])      # [0 2 4 6 8] - 2씩 건너뛰기

# 2차원 배열 슬라이싱
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(arr2d[1, :])   # [4 5 6] - 두 번째 행 전체
print(arr2d[:, 1])   # [2 5 8] - 두 번째 열 전체
```

**배열 연산**
```python
# 기본 수학 연산
a = np.array([1, 2, 3, 4])
b = np.array([5, 6, 7, 8])

print(a + b)         # 원소별 덧셈
print(a * b)         # 원소별 곱셈
print(a ** 2)        # 제곱

# 통계 함수
print(a.mean())      # 평균
print(a.std())       # 표준편차
print(a.sum())       # 합계
print(a.max())       # 최댓값

# 불리언 인덱싱
mask = a > 2
print(a[mask])       # [3 4] - 조건을 만족하는 원소만
```

**영화 평점 데이터 실습 예제**
```python
# MovieLens 데이터 활용 예제
# https://grouplens.org/datasets/movielens/
import numpy as np

# 가상의 평점 데이터 생성
ratings = np.random.uniform(1, 5, 1000000)  # 100만 개 평점 데이터

# 전체 평균 평점 계산
overall_mean = ratings.mean()
print(f"전체 평균 평점: {overall_mean:.2f}")

# 특정 조건 만족하는 데이터 필터링
high_ratings = ratings[ratings >= 4.0]
print(f"4점 이상 평점 개수: {len(high_ratings)}")

# CSV 파일로 저장
np.savetxt('ratings_summary.csv', [overall_mean], delimiter=',')
```

**심화 내용:**
- Broadcasting 규칙과 활용법
- np.where(), np.select() 조건부 연산
- einsum을 활용한 고급 행렬 연산
- 메모리 뷰(memoryview)를 활용한 최적화
- numba JIT 컴파일러와의 연동


//=============================


### 3-3. Pandas 라이브러리

**Pandas 기본 개념**
- NumPy와 함께 가장 많이 사용하는 데이터분석 라이브러리
- 행과 열로 구성된 데이터 객체 생성 및 조작
- 대용량 데이터를 안정적으로 처리하는 도구
- 주요 자료구조: Series(1차원), DataFrame(2차원)

**Series 자료구조**
```python
import pandas as pd

# Series 생성
x = pd.Series([4, 7, 5, 3])
print(x)

# 인덱스 설정
x2 = pd.Series([4, 7, 5, 3], index=['d', 'b', 'a', 'c'])
print(x2)

# 딕셔너리에서 Series 생성
sdata = {'Kim': 35000, 'Beomwoo': 67000, 'Joan': 12000, 'Choi': 4000}
salary_series = pd.Series(sdata)
salary_series.name = 'Salary'
salary_series.index.name = "Names"
print(salary_series)

# Series 연산
city_data = pd.Series([7, 3, 5, 8], index=['서울', '대구', '부산', '광주'])
print(city_data['서울'])      # 특정 값 접근
print(city_data[['서울', '부산']])  # 여러 값 접근
```

**DataFrame 자료구조**
```python
# DataFrame 생성
data = {
    'names': ['민준', '현우', '서연', '동현', '지현'],
    'years': [2013, 2014, 2015, 2016, 2015],
    'points': [1.5, 1.7, 3.6, 2.4, 2.9]
}
df = pd.DataFrame(data)
print(df)

# 기본 정보 확인
print(df.head())         # 처음 5행
print(df.tail())         # 마지막 5행
print(df.info())         # 데이터 타입과 null 값 정보
print(df.describe())     # 기술통계 정보
print(df.shape)          # 행, 열 수
```

**DataFrame 데이터 조작**
```python
# 열 선택 및 추가
print(df['names'])       # 단일 열 선택
print(df[['names', 'points']])  # 여러 열 선택

# 새로운 열 추가
df['grade'] = ['A', 'B', 'A', 'C', 'B']
df['total'] = df['points'] * 10

# 조건부 데이터 선택
high_performers = df[df['points'] > 2.0]
print(high_performers)

# 정렬
df_sorted = df.sort_values('points', ascending=False)
print(df_sorted)
```

**데이터 필터링과 그룹화**
```python
# Boolean 인덱싱
print(df[df['year'] > 2014])

# 복합 조건
result = df[(df['points'] > 2) & (df['points'] < 3)]
print(result)

# 그룹화
grouped = df.groupby('year')['points'].mean()
print(grouped)

# 결측값 처리
df_with_nan = df.copy()
df_with_nan.loc[0, 'points'] = np.nan
print(df_with_nan.dropna())      # 결측값이 있는 행 제거
print(df_with_nan.fillna(0))     # 결측값을 0으로 채우기
```

**파일 입출력**
```python
# CSV 파일 읽기/쓰기
df.to_csv('output.csv', index=False)
df_loaded = pd.read_csv('output.csv')

# Excel 파일 처리
# df.to_excel('output.xlsx', index=False)
# df_excel = pd.read_excel('output.xlsx')

# JSON 파일 처리
df.to_json('output.json', orient='records')
df_json = pd.read_json('output.json')
```

**심화 내용:**
- MultiIndex를 활용한 계층적 인덱싱
- pivot_table과 crosstab을 활용한 데이터 재구조화
- apply, map, applymap 함수의 차이점과 활용법
- 시계열 데이터 처리 (resample, rolling)
- 메모리 최적화 기법 (categorical data type, chunking)


### 3-4. 데이터 처리 실무 기법

**CSV 파일 처리 방법 비교**
```python
# 1. 순수 Python 방식
input_file = "data/input.csv"
output_file = "data/output1.csv"

with open(input_file, 'r', newline='') as reader:
    with open(output_file, 'w', newline='') as writer:
        header = reader.readline().strip()
        header_list = header.split(',')
        writer.write(','.join(map(str, header_list)) + '\n')
        
        for row in reader:
            row = row.strip()
            row_list = row.split(',')
            writer.write(','.join(map(str, row_list)) + '\n')

# 2. CSV 모듈 사용
import csv

with open(input_file, 'r', newline='') as csv_in_file:
    with open(output_file, 'w', newline='') as csv_out_file:
        filereader = csv.reader(csv_in_file, delimiter=',')
        filewriter = csv.writer(csv_out_file, delimiter=',')
        
        for row_list in filereader:
            filewriter.writerow(row_list)

# 3. Pandas 사용 (가장 효율적)
df = pd.read_csv(input_file)
df.to_csv(output_file, index=False)
```

**데이터 필터링 실무 예제**
```python
# 복잡한 조건 필터링
df = pd.read_csv("data/sales_data.csv")

# 비용 필드 전처리 ($1,234.56 형태를 숫자로 변환)
df['Cost'] = df['Cost'].str.strip(').str.replace(',', '').astype(float)

# 조건에 맞는 데이터 필터링
result = df.loc[
    (df['Supplier Name'].str.contains('A')) & 
    (df['Cost'] > 600000.0), :
]

result.to_csv("filtered_output.csv", index=False)
```

**항공 운항 데이터 분석 실습**
```python
# 여러 년도 데이터 통합 분석
df_2006 = pd.read_csv("data/2006.csv")
df_2007 = pd.read_csv("data/2007.csv")
df_2008 = pd.read_csv("data/2008.csv")

# 데이터 통합
df_combined = pd.concat([df_2006, df_2007, df_2008], ignore_index=True)

# 필요한 컬럼만 선택
df_analysis = df_combined[['Year', 'Month', 'ArrDelay', 'DepDelay']]

# 결측값 제거
df_clean = df_analysis.dropna(how="any")

# 년/월별 지연시간 통계
result = df_clean.groupby(['Year', 'Month'], as_index=False).agg({
    'ArrDelay': ['mean', 'sum', 'count'],
    'DepDelay': ['mean', 'sum', 'count']
})

result.to_csv("airline_analysis_result.csv")
```

**심화 내용:**
- 대용량 파일 처리를 위한 chunking 기법
- 병렬 처리를 활용한 데이터 처리 가속화
- SQL과의 연동 (SQLAlchemy 활용)
- 데이터 검증 및 품질 관리 기법


//=============================


### 3-5. Matplotlib 시각화

**Matplotlib 기본 설정**
```python
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from matplotlib import rc, font_manager

# 한글 폰트 설정 (Windows)
font_name = font_manager.FontProperties(
    fname="c:/Windows/Fonts/malgun.ttf"
).get_name()
rc('font', family=font_name)

# 음수 부호 깨짐 방지
plt.rcParams['axes.unicode_minus'] = False

# Jupyter Notebook에서 그래프 출력 설정
%matplotlib inline
```

**기본 그래프 유형**
```python
# 1. 선 그래프
x_values = list(range(1, 11))
y_values = [x**2 for x in x_values]

plt.figure(figsize=(10, 6))
plt.plot(x_values, y_values, linewidth=3, color='blue', label='y = x²')
plt.title("제곱수 그래프", fontsize=16)
plt.xlabel("X 값", fontsize=12)
plt.ylabel("Y 값", fontsize=12)
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()

# 2. 산점도
x1 = np.random.normal(1, 1, 100)
x2 = np.random.normal(-2, 4, 100)

plt.figure(figsize=(8, 6))
plt.scatter(x1, x2, c='red', alpha=0.6, s=50)
plt.title("산점도 예제", fontsize=16)
plt.xlabel("X1", fontsize=12)
plt.ylabel("X2", fontsize=12)
plt.show()

# 3. 히스토그램
data = np.random.normal(0, 1, 1000)

plt.figure(figsize=(8, 6))
plt.hist(data, bins=30, alpha=0.7, color='green', edgecolor='black')
plt.title("정규분포 히스토그램", fontsize=16)
plt.xlabel("값", fontsize=12)
plt.ylabel("빈도", fontsize=12)
plt.show()
```

**막대 그래프와 스타일링**
```python
# 막대 그래프 예제
plt.style.use('ggplot')  # R의 ggplot 스타일 적용

customers = ['A', 'B', 'C', 'D', 'E']
sale_amounts = [127, 90, 201, 111, 232]

plt.figure(figsize=(10, 6))
bars = plt.bar(customers, sale_amounts, 
               color=['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7'])

# 막대 위에 값 표시
for bar, amount in zip(bars, sale_amounts):
    plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 5,
             f'{amount}', ha='center', va='bottom', fontsize=10)

plt.title('고객별 판매금액', fontsize=16)
plt.xlabel('고객명', fontsize=12)
plt.ylabel('판매금액 (만원)', fontsize=12)
plt.ylim(0, max(sale_amounts) * 1.1)

# 그래프 저장
plt.savefig('sales_chart.png', dpi=300, bbox_inches='tight')
plt.show()
```

**시계열 데이터 시각화**
```python
# 온도 데이터 시각화 예제
import csv
from datetime import datetime

# 가상의 온도 데이터 생성
dates = pd.date_range('2024-01-01', periods=365, freq='D')
highs = 20 + 15 * np.sin(2 * np.pi * np.arange(365) / 365) + np.random.normal(0, 3, 365)
lows = highs - 10 + np.random.normal(0, 2, 365)

plt.figure(figsize=(12, 8))

# 최고/최저 온도 선 그래프
plt.plot(dates, highs, c='red', alpha=0.7, linewidth=1, label='최고온도')
plt.plot(dates, lows, c='blue', alpha=0.7, linewidth=1, label='최저온도')

# 온도 범위 채우기
plt.fill_between(dates, highs, lows, facecolor='lightblue', alpha=0.3)

plt.title('2024년 온도 통계', fontsize=18)
plt.xlabel('날짜', fontsize=14)
plt.ylabel('온도 (°C)', fontsize=14)
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()
```

**다중 서브플롯**
```python
# 2x2 서브플롯 생성
fig, axes = plt.subplots(2, 2, figsize=(12, 10))

# 각 서브플롯에 다른 그래프 그리기
x = np.linspace(0, 10, 100)

# 첫 번째 서브플롯: 사인 함수
axes[0, 0].plot(x, np.sin(x), 'b-')
axes[0, 0].set_title('sin(x)')
axes[0, 0].grid(True)

# 두 번째 서브플롯: 코사인 함수
axes[0, 1].plot(x, np.cos(x), 'r-')
axes[0, 1].set_title('cos(x)')
axes[0, 1].grid(True)

# 세 번째 서브플롯: 히스토그램
data = np.random.randn(1000)
axes[1, 0].hist(data, bins=30, alpha=0.7)
axes[1, 0].set_title('Random Distribution')

# 네 번째 서브플롯: 산점도
x_scatter = np.random.randn(50)
y_scatter = np.random.randn(50)
axes[1, 1].scatter(x_scatter, y_scatter, alpha=0.6)
axes[1, 1].set_title('Scatter Plot')

plt.tight_layout()
plt.show()
```

**심화 내용:**
- 3D 그래프 생성 및 조작 (mplot3d)
- 애니메이션 생성 (matplotlib.animation)
- 인터랙티브 그래프 (matplotlib widgets)
- Seaborn과의 연동을 통한 고급 시각화
- 커스텀 컬러맵 및 스타일 생성
- 벡터 그래픽 출력 (SVG, PDF) 최적화


### 3-6. 종합 실습 프로젝트

**실무 데이터 분석 파이프라인**
```python
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# 1. 데이터 수집 및 전처리
def load_and_clean_data(file_path):
    """데이터 로드 및 기본 전처리"""
    df = pd.read_csv(file_path)
    
    # 결측값 확인
    missing_data = df.isnull().sum()
    print(f"결측값 현황:\n{missing_data}")
    
    # 데이터 타입 최적화
    for col in df.select_dtypes(include=['object']).columns:
        if df[col].nunique() < len(df) * 0.5:  # 카테고리로 변환할 조건
            df[col] = df[col].astype('category')
    
    return df

# 2. 탐색적 데이터 분석
def perform_eda(df):
    """탐색적 데이터 분석 수행"""
    print("=== 데이터 기본 정보 ===")
    print(df.info())
    print("\n=== 기술통계 ===")
    print(df.describe())
    
    # 수치형 변수들의 분포 시각화
    numeric_cols = df.select_dtypes(include=[np.number]).columns
    n_cols = len(numeric_cols)
    
    if n_cols > 0:
        fig, axes = plt.subplots((n_cols + 2) // 3, 3, figsize=(15, 5 * ((n_cols + 2) // 3)))
        axes = axes.flatten() if n_cols > 3 else [axes]
        
        for i, col in enumerate(numeric_cols):
            df[col].hist(bins=30, ax=axes[i], alpha=0.7)
            axes[i].set_title(f'{col} 분포')
            axes[i].set_xlabel(col)
            axes[i].set_ylabel('빈도')
        
        # 빈 서브플롯 숨기기
        for i in range(len(numeric_cols), len(axes)):
            axes[i].set_visible(False)
        
        plt.tight_layout()
        plt.show()

# 3. 데이터 변환 및 파생변수 생성
def create_features(df):
    """파생변수 생성"""
    df_processed = df.copy()
    
    # 예시: 날짜 관련 파생변수
    if 'date' in df.columns:
        df_processed['date'] = pd.to_datetime(df_processed['date'])
        df_processed['year'] = df_processed['date'].dt.year
        df_processed['month'] = df_processed['date'].dt.month
        df_processed['day_of_week'] = df_processed['date'].dt.dayofweek
    
    return df_processed

# 4. 결과 시각화 및 저장
def create_dashboard(df, output_path='analysis_results'):
    """대시보드 생성 및 결과 저장"""
    # 여러 그래프를 포함한 종합 대시보드
    fig = plt.figure(figsize=(16, 12))
    
    # 레이아웃 설정
    gs = fig.add_gridspec(3, 3, hspace=0.3, wspace=0.3)
    
    # 메인 분석 결과들을 시각화...
    # (구체적인 분석 내용은 데이터에 따라 달라짐)
    
    plt.suptitle('데이터 분석 결과 대시보드', fontsize=16)
    plt.savefig(f'{output_path}_dashboard.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # 결과를 Excel 파일로 저장
    with pd.ExcelWriter(f'{output_path}_results.xlsx') as writer:
        df.to_excel(writer, sheet_name='원본데이터', index=False)
        df.describe().to_excel(writer, sheet_name='기술통계')

# 메인 분석 실행 함수
def main_analysis(data_path):
    """전체 분석 파이프라인 실행"""
    print("데이터 분석을 시작합니다...")
    
    # 단계별 실행
    df = load_and_clean_data(data_path)
    perform_eda(df)
    df_processed = create_features(df)
    create_dashboard(df_processed)
    
    print("분석이 완료되었습니다!")
    return df_processed

# 사용 예시
# result = main_analysis('your_data.csv')
```


//=============================


## 추가 학습 리소스

### 데이터 분석 학습 로드맵
1. **기초 단계**: NumPy, Pandas 기본 문법 숙달
2. **중급 단계**: 데이터 전처리, 탐색적 데이터 분석
3. **고급 단계**: 머신러닝, 딥러닝과의 연동

### 권장 실습 데이터셋
- **초보자**: Titanic, Iris, Boston Housing
- **중급자**: MovieLens, Stock Market Data
- **고급자**: 실제 업무 데이터 또는 Kaggle 대회 데이터

### 추가 라이브러리 학습 방향
- **Seaborn**: 고급 통계 시각화
- **Plotly**: 인터랙티브 시각화
- **Scikit-learn**: 머신러닝
- **Statsmodels**: 통계 분석

이 가이드를 통해 파이썬 데이터 분석의 핵심 라이브러리들을 체계적으로 학습하고, 
실제 데이터 분석 프로젝트에 적용할 수 있는 실력을 기를 수 있을 것입니다.