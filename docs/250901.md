## 🐍 파이썬 실습 코드 노트

### Chapter 2: 파이썬과 첫 만남 (기초 문법)

#### 🔸 자료형 변환 (Type Casting)
때로는 데이터의 종류를 바꿔주어야 할 때가 있어요. `int()`, `float()`, `str()` 같은 마법 주문으로 데이터의 타입을 자유롭게 변환할 수 있습니다.

```python
# float(10.3) -> int(10) : 실수를 정수로 바꾸면 소수점 이하는 버려져요.
a = int(10.3)
print(a)

# int(10) -> float(10.0) : 정수를 실수로 바꾸면 소수점이 붙어요.
b = float(a)
print(b)
```

```python
# 숫자 123을 문자열 "123"으로 변환합니다.
# 겉보기엔 같아도, 컴퓨터는 숫자와 글자를 다르게 인식해요!
x = str(123)
print(x)
print(type(x)) # type()으로 데이터의 종류를 확인할 수 있어요.
```

#### 🔸 Truthy & Falsy
파이썬에서는 `True`와 `False` 외에도 참/거짓으로 취급되는 값들이 있어요.
- `1`은 `True`와, `0`은 `False`와 같아요.
- 비어있는 문자열 `""`이나 비어있는 리스트 `[]`는 `False`로 취급된답니다.

```python
# 숫자 1과 True는 값이 같다고 판단해요.
print(1 == True)

# 비어있는 문자열 ""과 False는 값이 같다고 판단해요.
print("" == False)
```

#### 🔸 올바른 자료형으로 연산하기
문자열과 숫자는 바로 더할 수 없어요. 덧셈을 하려면, 문자열을 `float()`나 `int()`를 사용해 숫자로 바꿔주는 과정이 꼭 필요해요.

```python
a = '76.3' # 따옴표가 있으니 문자열!
b= float(a) # 문자열 '76.3'을 숫자 76.3으로 변환
c = 2.3

# print(a+c) # 에러! 문자열과 숫자는 바로 더할 수 없어요.
print(b + c) # 숫자끼리는 계산 가능!
print(type(a))
print(type(b))
print(type(c))
```

#### 🔸 문자열 출력 방식 (서식 지정)
문자열 안에 변수 값을 넣어서 출력하는 방법은 여러 가지가 있지만, **f-string** 방식이 가장 현대적이고 편리해요.

```python
name = "상용"
age = 42

# 1. % 연산자 방식 (옛날 방식)
print("이름 : %s, 나이 : %d" % (name, age))

# 2. f-string 방식 (파이썬 3.6+ 권장 ✨)
# 문자열 앞에 f를 붙이고, 변수를 {} 안에 넣어주면 끝!
print(f"이름 : {name}, 나이 : {age}")```

#### 🔸 사용자에게 입력받기: `input()`
`input()` 함수를 사용하면 사용자로부터 키보드 입력을 받을 수 있어요. `input()`으로 받은 값은 항상 **문자열** 타입이라는 점을 기억하세요!

```python
# 프롬프트(안내 메시지)를 띄우고 사용자 입력을 기다립니다.
lunch = input("오늘 점심 뭐 먹죠? ")
print(f"오늘 먹을 점심 메뉴 : {lunch}")
```

#### 🔸 리스트 (List) 다루기
리스트는 여러 개의 데이터를 한 바구니에 담아 관리하는 편리한 도구예요. 슬라이싱, `append()`, `extend()` 등 다양한 기능으로 자유롭게 다룰 수 있죠.

```python
a = [1, 2.0, "3"] # 여러 타입을 섞어 담을 수 있어요.
b = [4, 5, 6]

# 슬라이싱: 0번부터 2번 앞까지
print(a[0:2])
# 리버스 인덱싱: 뒤에서 2번째부터 끝까지
print(b[-2:])

# append: 리스트 맨 뒤에 요소 '하나' 추가
a.append(100)
print(a[:]) # 전체 출력

# extend: 리스트 맨 뒤에 다른 리스트 '통째로' 연결
a.extend(b)
print(a)

# step을 이용한 슬라이싱: 전체를 거꾸로 뒤집기
print(a[::-1])
# step을 이용한 슬라이싱: 두 칸씩 건너뛰기
print(a[::2])

# 덧셈 연산으로 리스트 연결하기
c = a + b
print(c)
```

```python
a = [1, 2, 3]
# insert(위치, 값): 원하는 위치에 요소 삽입
a.insert(1, 100)
print(a)

# remove(값): 리스트에서 해당 값을 찾아 제거
a.remove(100)
print(a)
```

#### 🔸 조건문과 반복문
- **`if-else`**: 조건이 참일 때와 거짓일 때, 각각 다른 코드를 실행해요.
- **`for`와 `range()`**: 정해진 횟수만큼 코드를 반복 실행할 때 환상의 짝꿍이죠! `range(시작, 끝, 증가폭)`을 기억하세요.

```python
if 3 > 4:
  print('참')
else:
  print('거짓')

# 0부터 10 전까지, 2씩 증가하며 반복
for i in range(0, 10, 2):
  print(i)

# 10부터 1 다음까지(즉, 2까지), 1씩 감소하며 반복
for i in range(10, 1, -1):
  print(i)
```

---

### Chapter 3: 함수와 문자열

#### 🔸 참조에 의한 호출 (Call by Object Reference) - 🔥핵심🔥
파이썬 함수에 리스트 같은 **가변(mutable) 객체**를 전달하면, 값 자체가 아닌 **'값이 저장된 위치 정보(주소)'**가 전달됩니다. 그래서 함수 안에서 리스트의 내용물을 바꾸면 원본 리스트도 함께 바뀌게 돼요!

```python
# 매개변수로 받은 리스트의 주소값을 추적하는 함수
def spam(eggs):
    print(f"함수 시작, eggs의 주소: {id(eggs)}")
    
    # .append()는 원본 리스트를 직접 수정합니다. 주소는 바뀌지 않아요.
    eggs.append(1) 
    print(f"append 후, eggs의 주소: {id(eggs)}") # 주소값 변경 없음
    
    # 중요! '=' 로 새로운 리스트를 할당하면,
    # eggs는 이제 완전히 다른 새 객체를 가리키게 됩니다.
    eggs = [2, 3] # 재할당!
    print(f"재할당 후, eggs의 주소: {id(eggs)}") # 주소값 변경됨

# 함수 사용
ham = [0] # 'ham'이라는 이름표가 [0] 리스트를 가리킴
print(f"함수 호출 전, ham의 주소: {id(ham)}")

spam(ham) # 함수에 ham의 '주소'를 전달

# spam 함수 안에서 ham의 내용물([0])은 [0, 1]로 바뀌었지만,
# ham 변수 자체가 가리키는 주소는 그대로입니다.
# 함수 내의 재할당은 함수 밖의 ham에 영향을 주지 못했어요!
print(f"함수 호출 후, ham의 주소: {id(ham)}")
print(f"최종 ham의 값: {ham}") # [0, 1]
```

#### 🔸 전역 변수와 `global` 키워드
함수 안에서 함수 밖의 전역 변수 값을 **수정**하고 싶다면, `global` 키워드로 "이 변수는 전역 변수입니다!"라고 선언해주어야 해요.

```python
def f():
    global s # "이제부터 제가 다룰 s는 전역 변수 s입니다!"
    s = "lsy" # 전역 변수 s의 값을 "lsy"로 변경
    print(s)

s = "abc" # 전역 변수 s
f()
print(s) # 함수 f()에 의해 값이 "lsy"로 변경되었어요.
```

#### 🔸 가변 인수와 언패킹
- **`*args`**: 함수에 몇 개의 인수가 들어올지 모를 때, `*`를 붙여주면 들어온 모든 위치 인수를 **튜플(tuple)**로 묶어서 받아요.
- **언패킹**: `*`는 튜플이나 리스트를 풀어헤쳐서 각각의 요소로 만들어주는 마법도 부린답니다.

```python
# *a가 (1, 2, 3, 4, 5)와 같은 튜플을 받아요.
def abc(*a):
    x, y, *z = a # 언패킹! x=첫번째, y=두번째, *z=나머지 전부
    return  x, y, z

print(abc(1, 2, 3))       # (1, 2, [3])
print(abc(1, 2, 3, 4))    # (1, 2, [3, 4])
print(abc(1, 2, 3, 4, 5)) # (1, 2, [3, 4, 5])
```

#### 🔸 키워드 가변 인수 `**kwargs`
`**`를 두 개 붙이면, `key=value` 형태로 들어오는 모든 키워드 인수를 **딕셔너리(dictionary)**로 묶어서 받아요.

```python
def aaa(**keys):
    print(keys)
    # 딕셔너리이므로, 키를 이용해 값에 접근할 수 있어요.
    print(f"value : {keys['first']}")

aaa(first=1, second=2, third=3)
```

#### 🔸 문자열 슬라이싱
문자열도 리스트처럼 순서가 있는 데이터라서, 슬라이싱을 똑같이 사용할 수 있어요.

```python
my_str = "abc"
# 0번부터 2번 앞까지, 1칸 간격으로
print(my_str[0:2:1])

# 전체를 거꾸로 뒤집기
print(my_str[::-1])
```

#### 🔸 파일 읽고 단어 수 세기
파일을 열어(`open`), 내용을 줄 단위로 읽고(`readlines`), 처리가 끝나면 꼭 닫아주어야(`close`) 해요. `strip()`으로 불필요한 공백을 제거하고, `count()`로 특정 단어의 개수를 셀 수 있습니다.

```python
f = open("yesterday.txt", "r")
yesterday_lyric = f.readlines()
f.close()

contents = ""
for line in yesterday_lyric:
    contents = contents + line.strip() + "\n"

# 대소문자 구분을 없애기 위해 모두 대문자로 바꾸고 "YESTERDAY" 개수 세기
number_of_yesterday = contents.upper().count("YESTERDAY")
print(f"노래 가사에서 'yesterday' 단어 개수: {number_of_yesterday}")
```

#### 🔸 f-string으로 소수점 자리 지정하기
f-string은 소수점 자릿수를 지정하는 데에도 매우 유용해요. AI 모델의 정확도나 오차율처럼 정밀한 값을 표현할 때 특히 빛을 발하죠.

```python
number = 3.14159265

# `{변수:.nf}` : 변수를 소수점 n번째 자리까지 표시
print(f"둘째 자리까지: {number:.2f}")
print(f"넷째 자리까지: {number:.4f}")
print(f"정수로: {number:.0f}")
```